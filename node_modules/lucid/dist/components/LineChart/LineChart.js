'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _toNumber2 = require('lodash/toNumber');

var _toNumber3 = _interopRequireDefault(_toNumber2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _identity2 = require('lodash/identity');

var _identity3 = _interopRequireDefault(_identity2);

var _compact2 = require('lodash/compact');

var _compact3 = _interopRequireDefault(_compact2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _chartHelpers = require('../../util/chart-helpers');

var _d3Scale = require('d3-scale');

var d3Scale = _interopRequireWildcard(_d3Scale);

var _d3TimeFormat = require('d3-time-format');

var d3TimeFormat = _interopRequireWildcard(_d3TimeFormat);

var _charts = require('../../constants/charts');

var chartConstants = _interopRequireWildcard(_charts);

var _Axis = require('../Axis/Axis');

var _Axis2 = _interopRequireDefault(_Axis);

var _AxisLabel = require('../AxisLabel/AxisLabel');

var _AxisLabel2 = _interopRequireDefault(_AxisLabel);

var _Legend = require('../Legend/Legend');

var _Legend2 = _interopRequireDefault(_Legend);

var _Lines = require('../Lines/Lines');

var _Lines2 = _interopRequireDefault(_Lines);

var _Points = require('../Points/Points');

var _Points2 = _interopRequireDefault(_Points);

var _ToolTip = require('../ToolTip/ToolTip');

var _ContextMenu = require('../ContextMenu/ContextMenu');

var _ContextMenu2 = _interopRequireDefault(_ContextMenu);

var _EmptyStateWrapper = require('../EmptyStateWrapper/EmptyStateWrapper');

var _EmptyStateWrapper2 = _interopRequireDefault(_EmptyStateWrapper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-LineChart');

var arrayOf = _propTypes2.default.arrayOf,
    func = _propTypes2.default.func,
    instanceOf = _propTypes2.default.instanceOf,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    shape = _propTypes2.default.shape,
    string = _propTypes2.default.string,
    bool = _propTypes2.default.bool,
    oneOfType = _propTypes2.default.oneOfType;

/**
 * {"categories": ["visualizations", "charts"], "madeFrom": ["ContextMenu", "ToolTip"]}
 *
 * The line chart presents data over time. Currently only dates are supported
 * on the x axis and numeric values on the y. If you need discrete values on
 * the x axis, consider using the `BarChart` instead.
 */

var LineChart = (0, _componentTypes.createClass)({
	displayName: 'LineChart',

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root element.
   */
		className: string,
		/**
   * Height of the chart.
   */
		height: number,
		/**
   * Width of the chart.
   */
		width: number,
		/**
   * An object defining the margins of the chart. These margins will contain
   * the axis and labels.
   */
		margin: shape({
			top: number,
			right: number,
			bottom: number,
			left: number
		}),
		/**
   * Data for the chart. E.g.
   *
   *     [
   *       { x: new Date('2015-01-01') , y: 1 } ,
   *       { x: new Date('2015-01-02') , y: 2 } ,
   *       { x: new Date('2015-01-03') , y: 3 } ,
   *       { x: new Date('2015-01-04') , y: 2 } ,
   *       { x: new Date('2015-01-05') , y: 5 } ,
   *     ]
   */
		data: arrayOf(object),
		/**
   * An object with human readable names for fields that will be used for
   * legends and tooltips. E.g:
   *
   *     {
   *       x: 'Date',
   *       y: 'Impressions',
   *     }
   *
   */
		legend: object,
		/**
   * Controls the visibility of the `LoadingMessage`.
   */
		isLoading: bool,
		/**
   * Show tool tips on hover.
   */
		hasToolTips: bool,
		/**
   * Show a legend at the bottom of the chart.
   */
		hasLegend: bool,
		/**
   * Takes one of the palettes exported from `lucid.chartConstants`.
   * Available palettes:
   *
   * - `PALETTE_6` (default)
   * - `PALETTE_30`
   * - `PALETTE_MONOCHROME_0_5`
   * - `PALETTE_MONOCHROME_1_5`
   * - `PALETTE_MONOCHROME_2_5`
   * - `PALETTE_MONOCHROME_3_5`
   * - `PALETTE_MONOCHROME_4_5`
   * - `PALETTE_MONOCHROME_5_5`
   *
   */
		palette: arrayOf(string),
		/**
   * You can pass in an object if you want to map fields to
   * `lucid.chartConstants` or custom colors:
   *
   *     {
   *       'imps': COLOR_0,
   *       'rev': COLOR_3,
   *       'clicks': '#abc123',
   *     }
   */
		colorMap: object,

		/**
   * The field we should look up your x data by. The data must be valid
   * javascript dates.
   */
		xAxisField: string,
		/**
   * The minimum date the x axis should display. Typically this will be the
   * smallest items from your dataset.
   */
		xAxisMin: instanceOf(Date),
		/**
   * The maximum date the x axis should display. This should almost always be
   * the largest date from your dataset.
   */
		xAxisMax: instanceOf(Date),
		/**
   * An optional function used to format your x axis data. If you don't
   * provide anything, we use the default D3 date variable formatter.
   */
		xAxisFormatter: func,
		/**
   * An optional function used to format your x axis dates in the tooltips.
   */
		xAxisTooltipFormatter: func,
		/**
   * There are some cases where you need to only show a "sampling" of ticks
   * on the x axis. This number will control that.
   */
		xAxisTickCount: number,
		/**
   * Set a title for the x axis.
   */
		xAxisTitle: string,
		/**
   * Set a color for the x axis title. Use the color constants exported off
   * `lucid.chartConstants`. E.g.:
   *
   * - `COLOR_0`
   * - `COLOR_GOOD`
   * - `'#123abc'` // custom color hex
   *
   * `number` is supported only for backwards compatability.
   */
		xAxisTitleColor: oneOfType([number, string]),

		/**
   * An array of your y axis fields. Typically this will just be a single
   * item unless you need to display multiple lines. The order of the array
   * determines the series order in the chart.
   */
		yAxisFields: arrayOf(string),
		/**
   * The minimum number the y axis should display. Typically this should be
   * `0`.
   */
		yAxisMin: number,
		/**
   * The maximum number the y axis should display. This should almost always
   * be the largest number from your dataset.
   */
		yAxisMax: number,
		/**
   * An optional function used to format your y axis data. If you don't
   * provide anything, we use the default D3 formatter.
   */
		yAxisFormatter: func,
		/**
   * Stack the y axis data. This is only useful if you have multiple
   * `yAxisFields`. Stacking will cause the chart to be aggregated by sum.
   */
		yAxisIsStacked: bool,
		/**
   * Display points along with the y axis lines.
   */
		yAxisHasPoints: bool,
		/**
   * There are some cases where you need to only show a "sampling" of ticks
   * on the y axis. This number will control that.
   */
		yAxisTickCount: number,
		/**
   * Set a title for the y axis.
   */
		yAxisTitle: string,
		/**
   * Set a color for the y axis title. Use the color constants exported off
   * `lucid.chartConstants`. E.g.:
   *
   * - `COLOR_0`
   * - `COLOR_GOOD`
   * - `'#123abc'` // custom color hex
   *
   * `number` is supported only for backwards compatability.
   */
		yAxisTitleColor: oneOfType([number, string]),
		/**
   * An optional function used to format your y axis titles and data in the
   * tooltips. The first value is the name of your y field, the second value
   * is your post-formatted y value, and the third value is your non-formatted
   * y-value.
   *
   * Signature: `(yField, yValueFormatted, yValue) => {}`
   */
		yAxisTooltipFormatter: func,
		/**
   * An optional function used to format data in the tooltips.
   */
		yAxisTooltipDataFormatter: func,
		/**
   * Set the starting index where colors start rotating for points and lines
   * along the y axis.
   */
		yAxisColorOffset: number,

		/**
   * An array of your y2 axis fields. Typically this will just be a single
   * item unless you need to display multiple lines. The order of the array
   * determines the series order in the chart.
   */
		y2AxisFields: arrayOf(string),
		/**
   * The minimum number the y2 axis should display. Typically this should be
   * `0`.
   */
		y2AxisMin: number,
		/**
   * The maximum number the y2 axis should display. This should almost always
   * be the largest number from your dataset.
   */
		y2AxisMax: number,
		/**
   * An optional function used to format your y2 axis data. If you don't
   * provide anything, we use the default D3 formatter.
   */
		y2AxisFormatter: func,
		/**
   * An optional function used to format data in the tooltips.
   */
		y2AxisTooltipDataFormatter: func,
		/**
   * Stack the y2 axis data. This is only useful if you have multiple
   * `y2AxisFields`. Stacking will cause the chart to be aggregated by sum.
   */
		y2AxisIsStacked: bool,
		/**
   * Display points along with the y2 axis lines.
   */
		y2AxisHasPoints: bool,
		/**
   * There are some cases where you need to only show a "sampling" of ticks
   * on the y2 axis. This number will control that.
   */
		y2AxisTickCount: number,
		/**
   * Set a title for the y2 axis.
   */
		y2AxisTitle: string,
		/**
   * Set a color for the y2 axis title. Use the color constants exported off
   * `lucid.chartConstants`. E.g.:
   *
   * - `COLOR_0`
   * - `COLOR_GOOD`
   * - `'#123abc'` // custom color hex
   *
   * `number` is supported only for backwards compatability.
   */
		y2AxisTitleColor: oneOfType([number, string]),
		/**
   * Set the starting index where colors start rotating for points and lines
   * along the y2 axis.
   */
		y2AxisColorOffset: number
	},

	statics: {
		MARGIN: {
			top: 10,
			right: 80,
			bottom: 65,
			left: 80
		}
	},

	getDefaultProps: function getDefaultProps() {
		return {
			height: 400,
			width: 1000,
			margin: {
				top: 10,
				right: 80,
				bottom: 65,
				left: 80
			},
			palette: chartConstants.PALETTE_6,
			hasToolTips: true,
			hasLegend: false,

			xAxisField: 'x',
			xAxisTickCount: null,
			xAxisTitle: null,
			xAxisTitleColor: '#000',
			// E.g. "Mon 06/06/2016 15:46:19"
			xAxisTooltipFormatter: d3TimeFormat.timeFormat('%a %x %X'),

			yAxisFields: ['y'],
			yAxisIsStacked: false,
			yAxisMin: 0,
			yAxisHasPoints: true,
			yAxisTickCount: null,
			yAxisTitle: null,
			yAxisTitleColor: '#000',
			yAxisTooltipFormatter: function yAxisTooltipFormatter(yField, yValueFormatted) {
				return yField + ': ' + yValueFormatted;
			},
			yAxisColorOffset: 0,

			y2AxisFields: null,
			y2AxisIsStacked: false,
			y2AxisHasPoints: true,
			y2AxisMin: 0,
			y2AxisTickCount: null,
			y2AxisTitle: null,
			y2AxisTitleColor: '#000',
			y2AxisColorOffset: 1
		};
	},
	getInitialState: function getInitialState() {
		return {
			isHovering: false
		};
	},


	components: {
		/**
   * Renders wrapper when the data table has no data.
   */
		EmptyStateWrapper: _EmptyStateWrapper2.default
	},

	render: function render() {
		var _this = this;

		var _props = this.props,
		    className = _props.className,
		    height = _props.height,
		    width = _props.width,
		    marginOriginal = _props.margin,
		    data = _props.data,
		    legend = _props.legend,
		    isLoading = _props.isLoading,
		    hasToolTips = _props.hasToolTips,
		    hasLegend = _props.hasLegend,
		    palette = _props.palette,
		    colorMap = _props.colorMap,
		    xAxisField = _props.xAxisField,
		    xAxisTickCount = _props.xAxisTickCount,
		    xAxisTitle = _props.xAxisTitle,
		    xAxisTitleColor = _props.xAxisTitleColor,
		    _props$xAxisFormatter = _props.xAxisFormatter,
		    xAxisFormatter = _props$xAxisFormatter === undefined ? _chartHelpers.formatDate : _props$xAxisFormatter,
		    xAxisTooltipFormatter = _props.xAxisTooltipFormatter,
		    _props$xAxisMin = _props.xAxisMin,
		    xAxisMin = _props$xAxisMin === undefined ? (0, _chartHelpers.minByFields)(data, xAxisField) : _props$xAxisMin,
		    _props$xAxisMax = _props.xAxisMax,
		    xAxisMax = _props$xAxisMax === undefined ? (0, _chartHelpers.maxByFields)(data, xAxisField) : _props$xAxisMax,
		    yAxisFields = _props.yAxisFields,
		    yAxisFormatter = _props.yAxisFormatter,
		    yAxisHasPoints = _props.yAxisHasPoints,
		    yAxisIsStacked = _props.yAxisIsStacked,
		    yAxisTickCount = _props.yAxisTickCount,
		    yAxisTitle = _props.yAxisTitle,
		    yAxisTitleColor = _props.yAxisTitleColor,
		    yAxisMin = _props.yAxisMin,
		    yAxisTooltipFormatter = _props.yAxisTooltipFormatter,
		    yAxisTooltipDataFormatter = _props.yAxisTooltipDataFormatter,
		    _props$yAxisMax = _props.yAxisMax,
		    yAxisMax = _props$yAxisMax === undefined ? yAxisIsStacked ? (0, _chartHelpers.maxByFieldsStacked)(data, yAxisFields) : (0, _chartHelpers.maxByFields)(data, yAxisFields) : _props$yAxisMax,
		    yAxisColorOffset = _props.yAxisColorOffset,
		    y2AxisFields = _props.y2AxisFields,
		    y2AxisFormatter = _props.y2AxisFormatter,
		    y2AxisTooltipDataFormatter = _props.y2AxisTooltipDataFormatter,
		    y2AxisHasPoints = _props.y2AxisHasPoints,
		    y2AxisIsStacked = _props.y2AxisIsStacked,
		    y2AxisTickCount = _props.y2AxisTickCount,
		    y2AxisTitle = _props.y2AxisTitle,
		    y2AxisTitleColor = _props.y2AxisTitleColor,
		    y2AxisMin = _props.y2AxisMin,
		    _props$y2AxisMax = _props.y2AxisMax,
		    y2AxisMax = _props$y2AxisMax === undefined ? y2AxisFields && y2AxisIsStacked ? (0, _chartHelpers.maxByFieldsStacked)(data, y2AxisFields) : (0, _chartHelpers.maxByFields)(data, y2AxisFields) : _props$y2AxisMax,
		    y2AxisColorOffset = _props.y2AxisColorOffset,
		    passThroughs = _objectWithoutProperties(_props, ['className', 'height', 'width', 'margin', 'data', 'legend', 'isLoading', 'hasToolTips', 'hasLegend', 'palette', 'colorMap', 'xAxisField', 'xAxisTickCount', 'xAxisTitle', 'xAxisTitleColor', 'xAxisFormatter', 'xAxisTooltipFormatter', 'xAxisMin', 'xAxisMax', 'yAxisFields', 'yAxisFormatter', 'yAxisHasPoints', 'yAxisIsStacked', 'yAxisTickCount', 'yAxisTitle', 'yAxisTitleColor', 'yAxisMin', 'yAxisTooltipFormatter', 'yAxisTooltipDataFormatter', 'yAxisMax', 'yAxisColorOffset', 'y2AxisFields', 'y2AxisFormatter', 'y2AxisTooltipDataFormatter', 'y2AxisHasPoints', 'y2AxisIsStacked', 'y2AxisTickCount', 'y2AxisTitle', 'y2AxisTitleColor', 'y2AxisMin', 'y2AxisMax', 'y2AxisColorOffset']);

		var _state = this.state,
		    isHovering = _state.isHovering,
		    mouseX = _state.mouseX;


		var margin = _extends({}, LineChart.MARGIN, marginOriginal);

		var svgClasses = cx(className, '&');

		var innerWidth = width - margin.left - margin.right;
		var innerHeight = height - margin.top - margin.bottom;

		var allYFields = (0, _compact3.default)(yAxisFields.concat(y2AxisFields));

		var xScale = d3Scale.scaleTime().domain([xAxisMin, xAxisMax]).range([0, innerWidth]);

		var yScale = d3Scale.scaleLinear().domain([yAxisMin, yAxisMax]).range([innerHeight, 0]);

		var y2Scale = y2AxisFields ? d3Scale.scaleLinear().domain([y2AxisMin, y2AxisMax]).range([innerHeight, 0]) : null;

		var yAxisFinalFormatter = yAxisFormatter || yScale.tickFormat();
		var y2AxisFinalFormatter = y2AxisFormatter ? y2AxisFormatter : y2Scale ? y2Scale.tickFormat() : _identity3.default;

		var xFinalFormatter = xAxisFormatter ? xAxisFormatter : xScale.tickFormat();
		var yFinalFormatter = yAxisTooltipDataFormatter ? yAxisTooltipDataFormatter : yAxisFinalFormatter;
		var y2FinalFormatter = y2AxisTooltipDataFormatter ? y2AxisTooltipDataFormatter : y2AxisFinalFormatter;

		// This logic is getting a bit complicated
		var yAxisHasPointsFinal = yAxisHasPoints || yAxisIsStacked;
		var yAxisHasLinesFinal = !(yAxisIsStacked && !yAxisHasPoints);

		var y2AxisHasPointsFinal = y2AxisHasPoints || y2AxisIsStacked;
		var y2AxisHasLinesFinal = !(y2AxisIsStacked && !y2AxisHasPoints);

		// This is used to map x mouse values back to data points.
		var xPointMap = (0, _reduce3.default)(data, function (acc, d) {
			// `floor` to avoid rounding errors, it doesn't need to be super precise
			// since we're dealing with pixels
			var point = Math.floor(xScale(d[xAxisField]));

			(0, _each3.default)(allYFields, function (field) {
				(0, _set3.default)(acc, point + '.y.' + field, d[field]);
				(0, _set3.default)(acc, point + '.x', d[xAxisField]);
			});

			return acc;
		}, {});
		var xPoints = (0, _map3.default)((0, _keys3.default)(xPointMap), _toNumber3.default);

		if ((0, _isEmpty3.default)(data) || width < 1 || height < 1 || isLoading) {
			var emptyStateWrapper = (0, _componentTypes.getFirst)(this.props, LineChart.EmptyStateWrapper, _react2.default.createElement(LineChart.EmptyStateWrapper, { Title: 'You have no data.' }));

			return _react2.default.createElement(
				_EmptyStateWrapper2.default,
				_extends({}, emptyStateWrapper.props, {
					isEmpty: (0, _isEmpty3.default)(data),
					isLoading: isLoading
				}),
				emptyStateWrapper.props.children,
				_react2.default.createElement(
					'svg',
					_extends({}, (0, _componentTypes.omitProps)(passThroughs, LineChart), {
						className: svgClasses,
						width: width,
						height: height
					}),
					_react2.default.createElement(
						'g',
						{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
						_react2.default.createElement(_Axis2.default, {
							orient: 'left',
							scale: yScale,
							tickFormat: yAxisFormatter,
							ref: 'yAxis'
						})
					),
					_react2.default.createElement(
						'g',
						{
							transform: 'translate(' + margin.left + ', ' + (innerHeight + margin.top) + ')'
						},
						_react2.default.createElement(_Axis2.default, {
							orient: 'bottom',
							scale: xScale,
							tickFormat: xFinalFormatter,
							ref: 'xAxis'
						})
					)
				)
			);
		}

		return _react2.default.createElement(
			'svg',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, LineChart), {
				className: svgClasses,
				width: width,
				height: height
			}),
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				hasToolTips && isHovering && !(0, _isNil3.default)(mouseX) ? _react2.default.createElement(
					_ToolTip.ToolTipDumb,
					{
						isExpanded: true,
						flyOutMaxWidth: 'none',
						alignment: mouseX < innerWidth * 0.15 ? 'start' : mouseX > innerWidth * 0.85 ? 'end' : 'center'
					},
					_react2.default.createElement(
						_ToolTip.ToolTipDumb.Target,
						{ elementType: 'g' },
						_react2.default.createElement('path', {
							className: cx('&-tooltip-line'),
							d: 'M' + mouseX + ',0 L' + mouseX + ',' + innerHeight
						})
					),
					_react2.default.createElement(
						_ToolTip.ToolTipDumb.Title,
						null,
						xAxisTooltipFormatter((0, _get3.default)(xPointMap, mouseX + '.x'))
					),
					_react2.default.createElement(
						_ToolTip.ToolTipDumb.Body,
						null,
						_react2.default.createElement(
							_Legend2.default,
							{ hasBorders: false, isReversed: yAxisIsStacked },
							(0, _map3.default)(yAxisFields, function (field, index) {
								return !(0, _isNil3.default)((0, _get3.default)(xPointMap, mouseX + '.y.' + field)) ? _react2.default.createElement(
									_Legend2.default.Item,
									{
										key: index,
										hasPoint: yAxisHasPointsFinal,
										hasLine: yAxisHasLinesFinal,
										color: (0, _get3.default)(colorMap, field, palette[(index + yAxisColorOffset) % palette.length]),
										pointKind: yAxisHasPoints ? index + yAxisColorOffset : 1
									},
									yAxisTooltipFormatter((0, _get3.default)(legend, field, field), yFinalFormatter((0, _get3.default)(xPointMap, mouseX + '.y.' + field)), (0, _get3.default)(xPointMap, mouseX + '.y.' + field))
								) : null;
							}),
							(0, _map3.default)(y2AxisFields, function (field, index) {
								return !(0, _isNil3.default)((0, _get3.default)(xPointMap, mouseX + '.y.' + field)) ? _react2.default.createElement(
									_Legend2.default.Item,
									{
										key: index,
										hasPoint: y2AxisHasPointsFinal,
										hasLine: y2AxisHasLinesFinal,
										color: (0, _get3.default)(colorMap, field, palette[y2AxisColorOffset + index + yAxisFields.length % palette.length]),
										pointKind: y2AxisHasPoints ? y2AxisColorOffset + index + yAxisFields.length : 1
									},
									yAxisTooltipFormatter((0, _get3.default)(legend, field, field), y2FinalFormatter((0, _get3.default)(xPointMap, mouseX + '.y.' + field)), (0, _get3.default)(xPointMap, mouseX + '.y.' + field))
								) : null;
							})
						)
					)
				) : null
			),
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + (innerHeight + margin.top) + ')' },
				_react2.default.createElement(_Axis2.default, {
					orient: 'bottom',
					scale: xScale,
					outerTickSize: 0,
					tickFormat: xFinalFormatter,
					tickCount: xAxisTickCount,
					ref: 'xAxis'
				}),
				hasLegend ? _react2.default.createElement(
					_ContextMenu2.default,
					{
						direction: 'down',
						alignment: 'center',
						directonOffset: (margin.bottom / 2 + _Legend2.default.HEIGHT / 2) * -1 /* should center the legend in the bottom margin */

					},
					_react2.default.createElement(
						_ContextMenu2.default.Target,
						{ elementType: 'g' },
						_react2.default.createElement('rect', {
							className: cx('&-invisible'),
							width: innerWidth,
							height: margin.bottom
						})
					),
					_react2.default.createElement(
						_ContextMenu2.default.FlyOut,
						{ className: cx('&-legend-container') },
						_react2.default.createElement(
							_Legend2.default,
							{ orient: 'horizontal' },
							(0, _map3.default)(yAxisFields, function (field, index) {
								return _react2.default.createElement(
									_Legend2.default.Item,
									{
										key: index,
										hasPoint: yAxisHasPointsFinal,
										hasLine: yAxisHasLinesFinal,
										color: (0, _get3.default)(colorMap, field, palette[index + yAxisColorOffset % palette.length]),
										pointKind: yAxisHasPoints ? index + yAxisColorOffset : 1
									},
									(0, _get3.default)(legend, field, field)
								);
							}),
							(0, _map3.default)(y2AxisFields, function (field, index) {
								return _react2.default.createElement(
									_Legend2.default.Item,
									{
										key: index,
										hasPoint: y2AxisHasPointsFinal,
										hasLine: y2AxisHasLinesFinal,
										color: (0, _get3.default)(colorMap, field, palette[y2AxisColorOffset + index + yAxisFields.length % palette.length]),
										pointKind: y2AxisHasPoints ? y2AxisColorOffset + index + yAxisFields.length : 1
									},
									(0, _get3.default)(legend, field, field)
								);
							})
						)
					)
				) : null
			),
			xAxisTitle ? _react2.default.createElement(
				'g',
				{
					transform: 'translate(' + margin.left + ', ' + (margin.top + innerHeight) + ')'
				},
				_react2.default.createElement(_AxisLabel2.default, {
					orient: 'bottom',
					width: innerWidth,
					height: margin.bottom,
					label: xAxisTitle,
					color: (0, _isString3.default)(xAxisTitleColor) ? xAxisTitleColor : palette[xAxisTitleColor % palette.length],
					ref: 'xAxisTitle'
				})
			) : null,
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Axis2.default, {
					orient: 'left',
					scale: yScale,
					tickFormat: yAxisFinalFormatter,
					tickCount: yAxisTickCount,
					ref: 'yAxis'
				})
			),
			yAxisTitle ? _react2.default.createElement(
				'g',
				{ transform: 'translate(0, ' + margin.top + ')' },
				_react2.default.createElement(_AxisLabel2.default, {
					orient: 'left',
					width: margin.left,
					height: innerHeight,
					label: yAxisTitle,
					color: (0, _isString3.default)(yAxisTitleColor) ? yAxisTitleColor : palette[yAxisTitleColor % palette.length],
					ref: 'yAxisTitle'
				})
			) : null,
			y2AxisFields ? _react2.default.createElement(
				'g',
				{
					transform: 'translate(' + (margin.left + innerWidth) + ', ' + margin.top + ')'
				},
				_react2.default.createElement(_Axis2.default, {
					orient: 'right',
					scale: y2Scale,
					tickFormat: y2AxisFinalFormatter,
					tickCount: y2AxisTickCount,
					ref: 'y2Axis'
				})
			) : null,
			y2AxisTitle ? _react2.default.createElement(
				'g',
				{
					transform: 'translate(' + (margin.left + innerWidth) + ', ' + margin.top + ')'
				},
				_react2.default.createElement(_AxisLabel2.default, {
					orient: 'right',
					width: margin.right,
					height: innerHeight,
					label: y2AxisTitle,
					color: (0, _isString3.default)(y2AxisTitleColor) ? y2AxisTitleColor : palette[y2AxisTitleColor % palette.length],
					ref: 'y2AxisTitle'
				})
			) : null,
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Lines2.default, {
					xScale: xScale,
					yScale: yScale,
					xField: xAxisField,
					yFields: yAxisFields,
					yStackedMax: yAxisMax,
					data: data,
					isStacked: yAxisIsStacked,
					colorMap: colorMap,
					palette: palette,
					colorOffset: yAxisColorOffset,
					ref: 'yLines'
				})
			),
			yAxisHasPoints ? _react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Points2.default, {
					xScale: xScale,
					yScale: yScale,
					xField: xAxisField,
					yFields: yAxisFields,
					yStackedMax: yAxisMax,
					data: data,
					isStacked: yAxisIsStacked,
					colorMap: colorMap,
					palette: palette,
					colorOffset: yAxisColorOffset,
					ref: 'yPoints'
				})
			) : null,
			y2AxisFields ? _react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Lines2.default, {
					xScale: xScale,
					yScale: y2Scale,
					xField: xAxisField,
					yFields: y2AxisFields,
					yStackedMax: y2AxisMax,
					data: data,
					isStacked: y2AxisIsStacked,
					colorOffset: y2AxisColorOffset + yAxisFields.length,
					colorMap: colorMap,
					palette: palette,
					ref: 'y2Lines'
				})
			) : null,
			y2AxisFields && y2AxisHasPoints ? _react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Points2.default, {
					xScale: xScale,
					yScale: y2Scale,
					xField: xAxisField,
					yFields: y2AxisFields,
					yStackedMax: y2AxisMax,
					data: data,
					isStacked: y2AxisIsStacked,
					colorOffset: y2AxisColorOffset + yAxisFields.length,
					colorMap: colorMap,
					palette: palette,
					ref: 'y2Points'
				})
			) : null,
			hasToolTips ? _react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement('rect', {
					className: cx('&-invisible'),
					width: innerWidth,
					height: innerHeight,
					onMouseMove: function onMouseMove(_ref) {
						var clientX = _ref.clientX,
						    target = _ref.target;

						_this.setState({
							isHovering: true,
							mouseX: (0, _chartHelpers.nearest)(xPoints, clientX - target.getBoundingClientRect().left)
						});
					},
					onMouseOut: function onMouseOut() {
						_this.setState({ isHovering: false });
					}
				})
			) : null
		);
	}
});

exports.default = LineChart;