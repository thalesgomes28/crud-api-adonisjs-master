'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.AutocompleteDumb = undefined;

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _escapeRegExp2 = require('lodash/escapeRegExp');

var _escapeRegExp3 = _interopRequireDefault(_escapeRegExp2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _noop2 = require('lodash/noop');

var _noop3 = _interopRequireDefault(_noop2);

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _componentTypes = require('../../util/component-types');

var _styleHelpers = require('../../util/style-helpers');

var _stateManagement = require('../../util/state-management');

var _textManipulation = require('../../util/text-manipulation');

var _Autocomplete = require('./Autocomplete.reducers');

var reducers = _interopRequireWildcard(_Autocomplete);

var _keyCode = require('../../constants/key-code');

var KEYCODE = _interopRequireWildcard(_keyCode);

var _DropMenu = require('../DropMenu/DropMenu');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-Autocomplete');

var arrayOf = _propTypes2.default.arrayOf,
    bool = _propTypes2.default.bool,
    func = _propTypes2.default.func,
    object = _propTypes2.default.object,
    shape = _propTypes2.default.shape,
    string = _propTypes2.default.string;

/**
 *
 * {"categories": ["controls", "text"], "madeFrom": ["DropMenu"]}
 *
 * A text input with suggested values displayed in an attached menu.
 */

var Autocomplete = (0, _componentTypes.createClass)({
	displayName: 'Autocomplete',

	_isPrivate: true,

	reducers: reducers,

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root elements.
   */
		className: string,
		/**
   * Styles that are passed through to root element.
   */
		style: object,
		/**
   * Disables the Autocomplete from being clicked or focused.
   */
		isDisabled: bool,
		/**
   * Array of suggested text input values shown in drop menu.
   */
		suggestions: arrayOf(string),
		/**
   * Text value of the input.
   */
		value: string,
		/**
   * Object of DropMenu props which are passed thru to the underlying DropMenu component.
   */
		DropMenu: shape(_DropMenu.DropMenuDumb.propTypes),
		/**
   * Called when the input value changes.
   * Has the signature `(value, {props, event}) => {}` where value is a string.
   */
		onChange: func,
		/**
   * Called when a suggestion is selected from the menu.
   * Has the signature `(optionIndex, {props, event}) => {}` where optionIndex is a number.
   */
		onSelect: func,
		/**
   * Called when menu is expected to expand.
   * Has the signature `({props, event}) => {}`.
   */
		onExpand: func
	},

	getDefaultProps: function getDefaultProps() {
		return {
			isDisabled: false,
			suggestions: [],
			value: '',
			onChange: _noop3.default,
			onSelect: _noop3.default,
			onExpand: _noop3.default,
			DropMenu: _DropMenu.DropMenuDumb.getDefaultProps()
		};
	},
	handleSelect: function handleSelect(optionIndex, _ref) {
		var event = _ref.event;
		var _props = this.props,
		    suggestions = _props.suggestions,
		    onChange = _props.onChange,
		    onSelect = _props.onSelect;


		onChange(suggestions[optionIndex], { event: event, props: this.props });
		onSelect(optionIndex, { event: event, props: this.props });
	},
	handleInput: function handleInput(event) {
		var _props2 = this.props,
		    onChange = _props2.onChange,
		    onExpand = _props2.onExpand,
		    onCollapse = _props2.DropMenu.onCollapse;


		onChange(event.target.value, { event: event, props: this.props });
		if (!(0, _isEmpty3.default)(event.target.value)) {
			onExpand({ event: event, props: this.props });
		} else {
			onCollapse();
		}
	},
	getInputValue: function getInputValue() {
		return (0, _get3.default)(this.refs, 'inputNode.value', this.props.value);
	},
	setInputValue: function setInputValue(value) {
		if (this.refs.inputNode) {
			this.refs.inputNode.value = value;
		}
	},
	handleInputKeydown: function handleInputKeydown(event) {
		var _props3 = this.props,
		    onExpand = _props3.onExpand,
		    _props3$DropMenu = _props3.DropMenu,
		    isExpanded = _props3$DropMenu.isExpanded,
		    focusedIndex = _props3$DropMenu.focusedIndex,
		    onCollapse = _props3$DropMenu.onCollapse;


		var value = this.getInputValue();

		if (event.keyCode === KEYCODE.Tab && isExpanded && focusedIndex !== null) {
			this.handleSelect(focusedIndex, { event: event, props: this.props });
			event.preventDefault();
		}

		if (event.keyCode === KEYCODE.ArrowDown && !isExpanded) {
			event.stopPropagation();

			if ((0, _isEmpty3.default)(value)) {
				onExpand({ event: event, props: this.props });
			}
		}

		if (event.keyCode === KEYCODE.Escape) {
			event.stopPropagation();
			onCollapse(event);
		}

		if (event.keyCode === KEYCODE.Enter && focusedIndex === null) {
			event.stopPropagation();
			onCollapse(event);
		}
	},
	handleControlClick: function handleControlClick(event) {
		var _props4 = this.props,
		    onExpand = _props4.onExpand,
		    _props4$DropMenu = _props4.DropMenu,
		    isExpanded = _props4$DropMenu.isExpanded,
		    onCollapse = _props4$DropMenu.onCollapse;


		if (event.target === this.refs.inputNode) {
			onExpand({ event: event, props: this.props });
		} else {
			if (isExpanded) {
				onCollapse(event);
			} else {
				onExpand({ event: event, props: this.props });
			}

			this.refs.inputNode.focus();
		}
	},
	componentDidMount: function componentDidMount() {
		var value = this.props.value;

		this.refs.inputNode.addEventListener('input', this.handleInput);
		this.setInputValue(value);
	},
	componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		var value = nextProps.value;

		if (value !== this.getInputValue()) {
			this.setInputValue(value);
		}
	},
	componentWillUnmount: function componentWillUnmount() {
		if (this.refs.inputNode) {
			this.refs.inputNode.removeEventListener('input', this.handleInput);
		}
	},
	render: function render() {
		var _props5 = this.props,
		    style = _props5.style,
		    className = _props5.className,
		    isDisabled = _props5.isDisabled,
		    dropMenuProps = _props5.DropMenu,
		    suggestions = _props5.suggestions,
		    passThroughs = _objectWithoutProperties(_props5, ['style', 'className', 'isDisabled', 'DropMenu', 'suggestions']);

		var isExpanded = dropMenuProps.isExpanded;


		var value = this.getInputValue();
		var valuePattern = new RegExp((0, _escapeRegExp3.default)(value), 'i');

		return _react2.default.createElement(
			_DropMenu.DropMenuDumb,
			_extends({}, dropMenuProps, {
				isDisabled: isDisabled,
				selectedIndices: [],
				className: cx('&', className),
				onSelect: this.handleSelect,
				style: style
			}),
			_react2.default.createElement(
				_DropMenu.DropMenuDumb.Control,
				{ onClick: this.handleControlClick },
				_react2.default.createElement(
					'div',
					{
						className: cx('&-Control', {
							'&-Control-is-expanded': isExpanded,
							'&-Control-is-disabled': isDisabled
						})
					},
					_react2.default.createElement('input', _extends({}, (0, _omit3.default)(passThroughs, ['onChange', 'onSelect', 'onExpand', 'value', 'children']), {
						type: 'text',
						className: cx('&-Control-input'),
						ref: 'inputNode',
						onKeyDown: this.handleInputKeydown,
						disabled: isDisabled
					}))
				)
			),
			value ? (0, _map3.default)(suggestions, function (suggestion) {
				return _react2.default.createElement(
					_DropMenu.DropMenuDumb.Option,
					{ key: 'AutocompleteOption' + suggestion },
					function () {
						var _partitionText = (0, _textManipulation.partitionText)(suggestion, valuePattern, value.length),
						    _partitionText2 = _slicedToArray(_partitionText, 3),
						    pre = _partitionText2[0],
						    match = _partitionText2[1],
						    post = _partitionText2[2];

						var formattedSuggestion = [];
						if (pre) {
							formattedSuggestion.push(_react2.default.createElement(
								'span',
								{
									key: 'AutocompleteOption-suggestion-pre-' + suggestion,
									className: cx('&-Option-suggestion-pre')
								},
								pre
							));
						}
						if (match) {
							formattedSuggestion.push(_react2.default.createElement(
								'span',
								{
									key: 'AutocompleteOption-suggestion-match-' + suggestion,
									className: cx('&-Option-suggestion-match')
								},
								match
							));
						}
						if (post) {
							formattedSuggestion.push(_react2.default.createElement(
								'span',
								{
									key: 'AutocompleteOption-suggestion-post-' + suggestion,
									className: cx('&-Option-suggestion-post')
								},
								post
							));
						}
						return formattedSuggestion;
					}()
				);
			}) : (0, _map3.default)(suggestions, function (suggestion) {
				return _react2.default.createElement(
					_DropMenu.DropMenuDumb.Option,
					{ key: 'AutocompleteOption' + suggestion },
					suggestion
				);
			})
		);
	}
});

exports.default = (0, _stateManagement.buildHybridComponent)(Autocomplete);
exports.AutocompleteDumb = Autocomplete;