'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _isNull2 = require('lodash/isNull');

var _isNull3 = _interopRequireDefault(_isNull2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _delay2 = require('lodash/delay');

var _delay3 = _interopRequireDefault(_delay2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactMotion = require('react-motion');

var _motionSpring = require('../../constants/motion-spring');

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-Collapsible');

var any = _propTypes2.default.any,
    bool = _propTypes2.default.bool,
    node = _propTypes2.default.node,
    number = _propTypes2.default.number,
    string = _propTypes2.default.string;

/**
 * {"categories": ["utility"]}
 *
 * This is a simple container that can render content as expanded or collapsed.
 */

var Collapsible = (0, _componentTypes.createClass)({
	displayName: 'Collapsible',
	_isPrivate: true,

	propTypes: {
		/**
   * Expandable content.
   */
		children: node,

		/**
   * Appended to the component-specific class names set on the root
   * element.
   */
		className: string,

		/**
   * Indicates that the component is in the "expanded" state when true
   * and in the "unexpanded" state when false.
   */
		isExpanded: bool,

		/**
   * Show an animated transition for alternating values of `isExpanded`.
   */
		isAnimated: bool,

		/**
   * If true, do not render children when fully collapsed.
   */
		isMountControlled: bool,

		/**
   * If `isMountControlled` is true, this value sets is the minimum height
   * the container needs to reach to not render any children.
   */
		mountControlThreshold: number,

		/**
   * Pass in a custom root element type.
   */
		rootType: any
	},

	getDefaultProps: function getDefaultProps() {
		return {
			isExpanded: true,
			isAnimated: true,
			isMountControlled: true,
			mountControlThreshold: 4,
			rootType: 'div'
		};
	},
	getInitialState: function getInitialState() {
		return {
			maxHeight: null
		};
	},
	storeRef: function storeRef(name) {
		var _this = this;

		return function (ref) {
			_this.Refs[name] = ref;
		};
	},
	componentWillMount: function componentWillMount() {
		this.Refs = {};
		this.isAnimated = false;
		this.delayTimer = null;
	},
	componentDidMount: function componentDidMount() {
		var _this2 = this;

		(0, _delay3.default)(function () {
			_this2.setState({
				maxHeight: (0, _get3.default)(_this2.Refs, 'root.scrollHeight')
			});
			_this2.isAnimated = _this2.props.isAnimated;
		}, 32);
	},
	componentDidUpdate: function componentDidUpdate() {
		var _this3 = this;

		this.isAnimated = false;
		this.delayTimer = (0, _delay3.default)(function () {
			if (_this3.props.isExpanded) {
				var maxHeight = (0, _get3.default)(_this3.Refs, 'root.scrollHeight');
				if (maxHeight !== _this3.state.maxHeight) {
					_this3.setState({
						maxHeight: maxHeight
					});
				}
			}
			_this3.isAnimated = _this3.props.isAnimated;
		}, 32);
	},
	componentWillUnmount: function componentWillUnmount() {
		this.delayTimer && clearTimeout(this.delayTimer);
	},
	render: function render() {
		var _this4 = this;

		var _props = this.props,
		    children = _props.children,
		    className = _props.className,
		    isExpanded = _props.isExpanded,
		    isMountControlled = _props.isMountControlled,
		    mountControlThreshold = _props.mountControlThreshold,
		    rootType = _props.rootType,
		    passThroughs = _objectWithoutProperties(_props, ['children', 'className', 'isExpanded', 'isMountControlled', 'mountControlThreshold', 'rootType']);

		var maxHeight = this.state.maxHeight;


		return _react2.default.createElement(
			_reactMotion.Motion,
			{
				style: this.isAnimated ? {
					height: isExpanded && !(0, _isNull3.default)(maxHeight) ? (0, _reactMotion.spring)(maxHeight, _motionSpring.QUICK_SLIDE_MOTION) : (0, _reactMotion.spring)(0, _motionSpring.QUICK_SLIDE_MOTION)
				} : {
					height: isExpanded && !(0, _isNull3.default)(maxHeight) ? maxHeight : 0
				}
			},
			function (tween) {
				return _react2.default.createElement(rootType, _extends({}, (0, _componentTypes.omitProps)(passThroughs, Collapsible), {
					ref: _this4.storeRef('root'),
					className: cx('&', className),
					style: _extends({
						height: tween.height !== maxHeight ? tween.height < 0 ? 0 : tween.height : null,
						overflow: 'hidden',
						padding: 0
					}, passThroughs.style)
				}), [_react2.default.createElement(
					'div',
					{
						key: 'content',
						className: cx('&-content'),
						style: { margin: 0 }
					},
					isMountControlled && !isExpanded ? (0, _isNull3.default)(maxHeight) || Math.abs(tween.height) > mountControlThreshold ? children : null : children
				)]);
			}
		);
	}
});

exports.default = Collapsible;