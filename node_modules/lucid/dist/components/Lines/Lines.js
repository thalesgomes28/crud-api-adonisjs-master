'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _max2 = require('lodash/max');

var _max3 = _interopRequireDefault(_max2);

var _isDate2 = require('lodash/isDate');

var _isDate3 = _interopRequireDefault(_isDate2);

var _isFinite2 = require('lodash/isFinite');

var _isFinite3 = _interopRequireDefault(_isFinite2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _chartHelpers = require('../../util/chart-helpers');

var _d3Shape = require('d3-shape');

var d3Shape = _interopRequireWildcard(_d3Shape);

var _charts = require('../../constants/charts');

var chartConstants = _interopRequireWildcard(_charts);

var _Line = require('../Line/Line');

var _Line2 = _interopRequireDefault(_Line);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-Lines');

var arrayOf = _propTypes2.default.arrayOf,
    func = _propTypes2.default.func,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    bool = _propTypes2.default.bool,
    string = _propTypes2.default.string;

/**
 * {"categories": ["visualizations", "chart primitives"], "madeFrom": ["Line"]}
 *
 * *For use within an `svg`*
 *
 * Lines are typically used to represent continuous data and can be stacked.
 */

var Lines = (0, _componentTypes.createClass)({
	displayName: 'Lines',

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root element.
   */
		className: string,
		/**
   * Top
   */
		top: number,
		/**
   * Left
   */
		left: number,
		/**
   * Takes one of the palettes exported from `lucid.chartConstants`.
   * Available palettes:
   *
   * - `PALETTE_6` (default)
   * - `PALETTE_30`
   * - `PALETTE_MONOCHROME_0_5`
   * - `PALETTE_MONOCHROME_1_5`
   * - `PALETTE_MONOCHROME_2_5`
   * - `PALETTE_MONOCHROME_3_5`
   * - `PALETTE_MONOCHROME_4_5`
   * - `PALETTE_MONOCHROME_5_5`
   *
   */
		palette: arrayOf(string),
		/**
   * You can pass in an object if you want to map fields to
   * `lucid.chartConstants` or custom colors:
   *
   *     {
   *       'imps': COLOR_0,
   *       'rev': COLOR_3,
   *       'clicks': '#abc123',
   *     }
   */
		colorMap: object,
		/**
   * De-normalized data, e.g.
   *
   *
   *     [
   *       { x: 'one'   , y: 1 },
   *       { x: 'two'   , y: 2 },
   *       { x: 'three' , y: 2 },
   *       { x: 'four'  , y: 3 },
   *       { x: 'five'  , y: 4 },
   *     ]
   *
   *
   * Or (be sure to set `yFields` to `['y0', 'y1', 'y2', 'y3']`)
   *
   *     [
   *       { x: 'one'   , y0: 1  , y1: 2 , y2: 3 , y3: 5 },
   *       { x: 'two'   , y0: 2  , y1: 3 , y2: 4 , y3: 6 },
   *       { x: 'three' , y0: 2  , y1: 4 , y2: 5 , y3: 6 },
   *       { x: 'four'  , y0: 3  , y1: 6 , y2: 7 , y3: 7 },
   *       { x: 'five'  , y0: 4  , y1: 8 , y2: 9 , y3: 8 },
   *       { x: 'six'   , y0: 20 , y1: 8 , y2: 9 , y3: 1 },
   *     ]
   *
   */
		data: arrayOf(object).isRequired,
		/**
   * The scale for the x axis. Must be a d3 scale. Lucid exposes the
   * `lucid.d3Scale` library for use here.
   */
		xScale: func.isRequired,
		/**
   * The scale for the y axis. Must be a d3 scale. Lucid exposes the
   * `lucid.d3Scale` library for use here.
   */
		yScale: func.isRequired,
		/**
   * Typically this number can be derived from the yScale. However when we're
   * `isStacked` we need to calculate a new domain for the yScale based on
   * the sum of the data. If you need explicit control of the y max when
   * stacking, pass it in here.
   */
		yStackedMax: number,
		/**
   * The field we should look up your x data by.
   */
		xField: string,
		/**
   * The field(s) we should look up your y data by. Each entry represents a
   * series. Your actual y data should be numeric.
   */
		yFields: arrayOf(string),
		/**
   * This will stack the data instead of grouping it. In order to stack the
   * data we have to calculate a new domain for the y scale that is based on
   * the `sum` of the data.
   */
		isStacked: bool,
		/**
   * Sometimes you might not want the colors to start rotating at the blue
   * color, this number will be added the line index in determining which
   * color the lines are.
   */
		colorOffset: number
	},

	getDefaultProps: function getDefaultProps() {
		return {
			xField: 'x',
			yFields: ['y'],
			isStacked: false,
			colorOffset: 0,
			palette: chartConstants.PALETTE_6
		};
	},
	render: function render() {
		var _props = this.props,
		    className = _props.className,
		    data = _props.data,
		    isStacked = _props.isStacked,
		    palette = _props.palette,
		    colorMap = _props.colorMap,
		    colorOffset = _props.colorOffset,
		    xScale = _props.xScale,
		    xField = _props.xField,
		    yFields = _props.yFields,
		    yScaleOriginal = _props.yScale,
		    yStackedMax = _props.yStackedMax,
		    passThroughs = _objectWithoutProperties(_props, ['className', 'data', 'isStacked', 'palette', 'colorMap', 'colorOffset', 'xScale', 'xField', 'yFields', 'yScale', 'yStackedMax']);

		// Copy the original so we can mutate it


		var yScale = yScaleOriginal.copy();

		// If we are stacked, we need to calculate a new domain based on the sum of
		// the various series' y data. One row per series.
		var transformedData = isStacked ? d3Shape.stack().keys(yFields)(data) : (0, _chartHelpers.groupByFields)(data, yFields);

		var area = isStacked ? d3Shape.area().defined(function (a) {
			return (0, _isFinite3.default)(a[0]) && (0, _isFinite3.default)(a[1]);
		}).x(function (a, i) {
			return xScale(data[i][xField]);
		}).y0(function (a) {
			return yScale(a[1]);
		}).y1(function (a) {
			return yScale(a[0]);
		}) : d3Shape.area().defined(function (a) {
			return (0, _isFinite3.default)(a) || (0, _isDate3.default)(a);
		}).x(function (a, i) {
			return xScale(data[i][xField]);
		}).y(function (a) {
			return yScale(a);
		});

		// If we are stacked, we need to calculate a new domain based on the sum of
		// the various group's y data
		if (isStacked) {
			yScale.domain([yScale.domain()[0], // only stacks well if this is `0`
			yStackedMax || (0, _max3.default)((0, _flatten3.default)((0, _last3.default)(transformedData)))]);
		}

		return _react2.default.createElement(
			'g',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, Lines), { className: cx(className, '&') }),
			(0, _map3.default)(transformedData, function (d, dIndex) {
				return _react2.default.createElement(
					'g',
					{ key: dIndex },
					_react2.default.createElement(_Line2.default, {
						color: (0, _get3.default)(colorMap, yFields[dIndex], palette[(dIndex + colorOffset) % palette.length]),
						d: area(d)
					})
				);
			})
		);
	}
});

exports.default = Lines;