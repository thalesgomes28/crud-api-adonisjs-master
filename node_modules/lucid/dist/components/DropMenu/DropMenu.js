'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DropMenuDumb = undefined;

var _every2 = require('lodash/every');

var _every3 = _interopRequireDefault(_every2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _includes2 = require('lodash/includes');

var _includes3 = _interopRequireDefault(_includes2);

var _findIndex2 = require('lodash/findIndex');

var _findIndex3 = _interopRequireDefault(_findIndex2);

var _findLastIndex2 = require('lodash/findLastIndex');

var _findLastIndex3 = _interopRequireDefault(_findLastIndex2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _first2 = require('lodash/first');

var _first3 = _interopRequireDefault(_first2);

var _isNull2 = require('lodash/isNull');

var _isNull3 = _interopRequireDefault(_isNull2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _groupBy2 = require('lodash/groupBy');

var _groupBy3 = _interopRequireDefault(_groupBy2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _uniqueId2 = require('lodash/uniqueId');

var _uniqueId3 = _interopRequireDefault(_uniqueId2);

var _noop2 = require('lodash/noop');

var _noop3 = _interopRequireDefault(_noop2);

var _size2 = require('lodash/size');

var _size3 = _interopRequireDefault(_size2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _domHelpers = require('../../util/dom-helpers');

var _stateManagement = require('../../util/state-management');

var _keyCode = require('../../constants/key-code');

var KEYCODE = _interopRequireWildcard(_keyCode);

var _DropMenu = require('./DropMenu.reducers');

var reducers = _interopRequireWildcard(_DropMenu);

var _ContextMenu = require('../ContextMenu/ContextMenu');

var _ContextMenu2 = _interopRequireDefault(_ContextMenu);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function joinArray(array, getSeparator) {
	return (0, _reduce3.default)(array, function (newArray, element, index) {
		newArray.push(element);
		if (index < (0, _size3.default)(array) - 1) {
			newArray.push(getSeparator(element, index, array));
		}
		return newArray;
	}, []);
}

function isOptionVisible(option) {
	return !option.optionProps.isHidden;
}

var cx = _styleHelpers.lucidClassNames.bind('&-DropMenu');

var any = _propTypes2.default.any,
    arrayOf = _propTypes2.default.arrayOf,
    bool = _propTypes2.default.bool,
    func = _propTypes2.default.func,
    node = _propTypes2.default.node,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    oneOf = _propTypes2.default.oneOf,
    string = _propTypes2.default.string;

/**
 *
 * {"categories": ["helpers"], "madeFrom": ["ContextMenu"]}
 *
 * This is a helper component used to render a menu of options attached to any control. Supports option groups with and without labels as well as special options with a `null` index for unselect.
 */

var DropMenu = (0, _componentTypes.createClass)({
	displayName: 'DropMenu',

	reducers: reducers,

	components: {
		/**
   * An optional header to be displayed within the expanded Flyout, above all `Option`s.
   */
		Header: (0, _componentTypes.createClass)({
			displayName: 'DropMenu.Header',
			propName: 'Header'
		}),
		/**
   * Renders a `<div>` that acts as the control target which the flyout menu is anchored to. Only one `Control` is used.
   */
		Control: (0, _componentTypes.createClass)({
			displayName: 'DropMenu.Control',
			propName: 'Control'
		}),
		/**
   * A special kind of `Option` that is always rendered at the top of the menu and has an `optionIndex` of `null`. Useful for unselect.
   */
		OptionGroup: (0, _componentTypes.createClass)({
			displayName: 'DropMenu.OptionGroup',
			propName: 'OptionGroup',
			propTypes: {
				/**
     * hides the `OptionGroup` from the list.
     */
				isHidden: bool
			},
			getDefaultProps: function getDefaultProps() {
				return {
					isHidden: false
				};
			}
		}),
		/**
   * Renders a `<div>` that acts as an option in the menu.
   */
		Option: (0, _componentTypes.createClass)({
			displayName: 'DropMenu.Option',
			propName: 'Option',
			propTypes: {
				/**
     * disables selection of the `Option`.
     */
				isDisabled: bool,
				/**
     * hides the `Option` from the list.
     */
				isHidden: bool,
				/**
     * controls wrapping of the text.
     */
				isWrapped: bool
			},
			getDefaultProps: function getDefaultProps() {
				return {
					isDisabled: false,
					isHidden: false,
					isWrapped: true
				};
			}
		}),
		/**
   * A special kind of `Option` that is always rendered at the top of the menu and has an `optionIndex` of `null` used for deselecting.
   */
		NullOption: (0, _componentTypes.createClass)({
			displayName: 'DropMenu.NullOption',
			propName: 'NullOption'
		}),
		/**
   * Props that are passed through to the underling ContextMenu.
   */
		ContextMenu: (0, _componentTypes.createClass)({
			displayName: 'DropMenu.ContextMenu',
			propName: 'ContextMenu'
		})
	},

	propTypes: {
		/**
   * Should be instances of {`DropMenu.Control`, `DropMenu.Option`, `DropMenu.OptionGroup`, `DropMenu.Nulloption`}. Other direct child elements will not render.
   */
		children: node,
		/**
   * Appended to the component-specific class names set on the root elements. Applies to *both* the control and the flyout menu.
   */
		className: string,
		/**
   * Styles that are passed through to root element.
   */
		style: object,
		/**
   * Disables the DropMenu from being clicked or focused.
   */
		isDisabled: bool,
		/**
   * Renders the flyout menu adjacent to the control.
   */
		isExpanded: bool,
		/**
   * Sets the direction the flyout menu will render relative to the control.
   */
		direction: oneOf(['down', 'up']),
		/**
   * Sets the alignment the flyout menu will render relative to the control.
   */
		alignment: oneOf(['start', 'center', 'end']),
		/**
   * An array of currently selected `DropMenu.Option` indices.
   */
		selectedIndices: arrayOf(number),
		/**
   * The currently focused index of `DropMenu.Option`. Can also be `null`.
   */
		focusedIndex: number,
		/**
   * The `id` of the flyout menu portal element that is appended to `document.body`. Defaults to a generated id.
   */
		portalId: string,
		/**
   * Styles that are passed through to the ContextMenu FlyOut element.
   */
		flyOutStyle: object,
		/**
   * Styles that are passed through to the option container element.
   */
		optionContainerStyle: object,
		/**
   * Called when collapsed and the control is clicked, or when the control has focus and the Down Arrow is pressed.
   * Has the signature `({ props, event }) => {}`
   */
		onExpand: func,
		/**
   * Called when expanded and the user clicks the control or outside of the menu, or when the control has focus and the Escape key is pressed
   * Has the signature `({ props, event }) => {}`
   */
		onCollapse: func,
		/**
   * Called when an option is clicked, or when an option has focus and the Enter key is pressed.
   * Has the signature `(optionIndex, {props, event}) => {}` where optionIndex can be a number or `null`.
   */
		onSelect: func,
		/**
   * Called when expanded and the the Down Arrow key is pressed. Not called when focus is on the last option.
   * Has the signature `({ props, event }) => {}`
   */
		onFocusNext: func,
		/**
   * Called when expanded and the the Up Arrow key is pressed. Not called when focus is on the first option.
   * Has the signature `({ props, event }) => {}`
   */
		onFocusPrev: func,
		/**
   * Called when the mouse moves over an option.
   * Has the signature `(optionIndex) => {}` where optionIndex can be a number or `null`.
   */
		onFocusOption: func,
		/**
   * *Child Element* - The control target which the flyout menu is anchored to. Only one `Control` is used.
   */
		Control: any,
		/**
   * *Child Element* - These are menu options. The `optionIndex` is in-order of rendering regardless of group nesting, starting with index `0`.
   * Each `Option` may be passed a prop called `isDisabled` to disable selection of that `Option`.
   * Any other props pass to Option will be available from the `onSelect` handler.
   */
		Option: any,
		/**
   * *Child Element* - Used to group `Option`s within the menu. Any non-`Option`s passed in will be rendered as a label for the group.
   */
		OptionGroup: any,
		/**
   * *Child Element* - A special kind of `Option` that is always rendered at the top of the menu and has an `optionIndex` of `null`. Useful for unselect.
   */
		NullOption: any,
		/**
   * *Child Element* - An optional header to be displayed within the expanded Flyout, above all `Option`s.
   */
		Header: any
	},

	getDefaultProps: function getDefaultProps() {
		return {
			isDisabled: false,
			isExpanded: false,
			direction: 'down',
			alignment: 'start',
			selectedIndices: [],
			focusedIndex: null,
			flyOutStyle: { maxHeight: '18em' },
			onExpand: _noop3.default,
			onCollapse: _noop3.default,
			onSelect: _noop3.default,
			onFocusNext: _noop3.default,
			onFocusPrev: _noop3.default,
			onFocusOption: _noop3.default,
			ContextMenu: _ContextMenu2.default.getDefaultProps()
		};
	},
	getInitialState: function getInitialState() {
		return {
			isMouseTriggered: false,
			optionGroups: [],
			flattenedOptionsData: [],
			ungroupedOptionData: [],
			optionGroupDataLookup: {},
			portalId: this.props.portalId || (0, _uniqueId3.default)('DropMenu-Portal-')
		};
	},


	statics: {
		preprocessOptionData: function preprocessOptionData(props) {
			var ParentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DropMenu;
			var OptionGroup = ParentType.OptionGroup,
			    Option = ParentType.Option,
			    NullOption = ParentType.NullOption;


			var optionGroups = (0, _map3.default)((0, _componentTypes.findTypes)(props, OptionGroup), 'props'); // find all OptionGroup props
			var ungroupedOptions = (0, _map3.default)((0, _componentTypes.findTypes)(props, Option), 'props'); // find all ungrouped Option props
			var nullOptions = NullOption ? (0, _map3.default)((0, _componentTypes.findTypes)(props, NullOption), 'props') : []; // find all NullOption props

			// flatten grouped options into array of objects to associate { index, group index, and props } for each option
			var groupedOptionData = (0, _reduce3.default)(optionGroups, function (memo, optionGroupProps, optionGroupIndex) {
				var groupedOptions = (0, _map3.default)((0, _componentTypes.findTypes)(optionGroupProps, Option), 'props'); // find all Option props for current group
				return memo.concat((0, _map3.default)(groupedOptions, function (optionProps, localOptionIndex) {
					return {
						localOptionIndex: localOptionIndex,
						optionIndex: (0, _size3.default)(memo) + localOptionIndex, // add current index to current array length to get final option index
						optionGroupIndex: optionGroupIndex, // store option group index to associate option back to group
						optionProps: optionProps
					};
				}));
			}, []);

			// create lookup object for options by their group index
			var optionGroupDataLookup = (0, _groupBy3.default)(groupedOptionData, 'optionGroupIndex');

			// store ungrouped options into array of objects to associate { index, and props } for each option
			var ungroupedOptionData = (0, _map3.default)(ungroupedOptions, function (optionProps, localOptionIndex) {
				return {
					localOptionIndex: localOptionIndex,
					optionIndex: (0, _size3.default)(groupedOptionData) + localOptionIndex, // add current index to grouped options array length to get final option index (grouped options rendered first)
					optionGroupIndex: null, // ungrouped options have no `optionGroupIndex`
					optionProps: optionProps
				};
			});

			// concatenate grouped options array with ungrouped options array to get flat list of all options
			var flattenedOptionsData = groupedOptionData.concat(ungroupedOptionData);

			return {
				optionGroups: optionGroups,
				optionGroupDataLookup: optionGroupDataLookup,
				ungroupedOptionData: ungroupedOptionData,
				flattenedOptionsData: flattenedOptionsData,
				nullOptions: nullOptions
			};
		}
	},

	getPreprocessedOptionData: function getPreprocessedOptionData(props) {
		return DropMenu.preprocessOptionData(props, DropMenu);
	},
	handleKeydown: function handleKeydown(event) {
		var props = this.props,
		    _props = this.props,
		    isExpanded = _props.isExpanded,
		    focusedIndex = _props.focusedIndex,
		    onExpand = _props.onExpand,
		    onCollapse = _props.onCollapse,
		    onSelect = _props.onSelect,
		    onFocusOption = _props.onFocusOption;
		var _state = this.state,
		    flattenedOptionsData = _state.flattenedOptionsData,
		    nullOptions = _state.nullOptions;


		this.setState({
			isMouseTriggered: false
		});

		if (isExpanded) {
			if (event.keyCode === KEYCODE.Enter) {
				event.preventDefault();
				var focusedOptionData = (0, _get3.default)(flattenedOptionsData, focusedIndex, null);
				var focusedOptionProps = (0, _get3.default)(focusedOptionData, 'optionProps', {});
				if (focusedOptionData && !focusedOptionProps.isDisabled) {
					onSelect(focusedIndex, { props: focusedOptionProps, event: event });
				} else if ((0, _isNull3.default)(focusedIndex)) {
					onSelect(null, { props: (0, _first3.default)(nullOptions), event: event });
				}
			}
			if (event.keyCode === KEYCODE.Escape) {
				event.preventDefault();
				onCollapse({ props: props, event: event });
			}
			if (event.keyCode === KEYCODE.ArrowUp) {
				if ((0, _isNumber3.default)(focusedIndex) || (0, _isNull3.default)(focusedIndex)) {
					if (focusedIndex === 0) {
						if (!(0, _isEmpty3.default)(nullOptions)) {
							event.preventDefault();
							onFocusOption(null, { props: props, event: event });
						}
					}
					if (focusedIndex > 0) {
						event.preventDefault();
						onFocusOption((0, _findLastIndex3.default)(flattenedOptionsData, isOptionVisible, focusedIndex - 1), { props: props, event: event });
					}
				} else {
					event.preventDefault();
					onFocusOption((0, _findLastIndex3.default)(flattenedOptionsData, isOptionVisible, focusedIndex - 1), { props: props, event: event });
				}
			}
			if (event.keyCode === KEYCODE.ArrowDown) {
				if ((0, _isNumber3.default)(focusedIndex)) {
					if (focusedIndex < (0, _size3.default)(flattenedOptionsData) - 1) {
						event.preventDefault();
						onFocusOption((0, _findIndex3.default)(flattenedOptionsData, isOptionVisible, focusedIndex + 1), { props: props, event: event });
					}
				} else {
					event.preventDefault();
					onFocusOption((0, _findIndex3.default)(flattenedOptionsData, isOptionVisible, focusedIndex), { props: props, event: event });
				}
			}
		} else {
			if (event.keyCode === KEYCODE.ArrowDown) {
				event.preventDefault();
				onExpand({ props: props, event: event });
			}
		}
	},
	handleClick: function handleClick(event) {
		var props = this.props,
		    _props2 = this.props,
		    isExpanded = _props2.isExpanded,
		    onExpand = _props2.onExpand,
		    onCollapse = _props2.onCollapse;


		if (isExpanded) {
			onCollapse({ props: props, event: event });
		} else {
			onExpand({ props: props, event: event });
		}
	},
	handleMouseFocusOption: function handleMouseFocusOption(optionIndex, optionProps, event) {
		var _props3 = this.props,
		    focusedIndex = _props3.focusedIndex,
		    onFocusOption = _props3.onFocusOption;


		this.setState({
			isMouseTriggered: true
		});

		if (!optionProps.isDisabled && focusedIndex !== optionIndex) {
			onFocusOption(optionIndex, { props: optionProps, event: event });
		}
	},
	handleSelectOption: function handleSelectOption(optionIndex, optionProps, event) {
		var onSelect = this.props.onSelect;


		if (!optionProps.isDisabled) {
			onSelect(optionIndex, { props: optionProps, event: event });
		}
	},
	renderOption: function renderOption(optionProps, optionIndex, isGrouped) {
		var _this = this;

		var _props4 = this.props,
		    selectedIndices = _props4.selectedIndices,
		    focusedIndex = _props4.focusedIndex;
		var isMouseTriggered = this.state.isMouseTriggered;
		var isDisabled = optionProps.isDisabled,
		    isHidden = optionProps.isHidden,
		    isWrapped = optionProps.isWrapped;


		var isFocused = optionIndex === focusedIndex;
		var isSelected = (0, _includes3.default)(selectedIndices, optionIndex);

		return !isHidden && _react2.default.createElement('div', _extends({
			key: 'DropMenuOption' + optionIndex
		}, (0, _componentTypes.omitProps)(optionProps, DropMenu.Option), {
			onClick: function onClick(event) {
				return _this.handleSelectOption(optionIndex, optionProps, event);
			},
			onMouseMove: function onMouseMove(event) {
				return _this.handleMouseFocusOption(optionIndex, optionProps, event);
			},
			className: cx('&-Option', {
				'&-Option-is-grouped': isGrouped,
				'&-Option-is-focused': isFocused,
				'&-Option-is-selected': isSelected,
				'&-Option-is-disabled': isDisabled,
				'&-Option-is-null': (0, _isNull3.default)(optionIndex),
				'&-Option-is-wrapped': isWrapped
			}, optionProps.className),
			ref: function ref(optionDOMNode) {
				if (isFocused && !isMouseTriggered) {
					(0, _domHelpers.scrollParentTo)(optionDOMNode, _this._header && _this._header.offsetHeight);
				}
			}
		}));
	},
	componentWillMount: function componentWillMount() {
		// preprocess the options data before rendering
		this.setState(this.getPreprocessedOptionData(this.props));
	},
	componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		// only preprocess options data when it changes (via new props) - better performance than doing this each render
		this.setState(this.getPreprocessedOptionData(nextProps));
	},
	render: function render() {
		var _this2 = this;

		var _props5 = this.props,
		    className = _props5.className,
		    style = _props5.style,
		    isDisabled = _props5.isDisabled,
		    isExpanded = _props5.isExpanded,
		    direction = _props5.direction,
		    alignment = _props5.alignment,
		    onCollapse = _props5.onCollapse,
		    flyOutStyle = _props5.flyOutStyle,
		    optionContainerStyle = _props5.optionContainerStyle;
		var _state2 = this.state,
		    optionGroups = _state2.optionGroups,
		    ungroupedOptionData = _state2.ungroupedOptionData,
		    optionGroupDataLookup = _state2.optionGroupDataLookup,
		    nullOptions = _state2.nullOptions,
		    portalId = _state2.portalId;


		var contextMenuProps = (0, _get3.default)((0, _componentTypes.getFirst)(this.props, DropMenu.ContextMenu), 'props', {});
		var controlProps = (0, _get3.default)((0, _componentTypes.getFirst)(this.props, DropMenu.Control), 'props', {});
		var headerProps = (0, _get3.default)((0, _componentTypes.getFirst)(this.props, DropMenu.Header), 'props', {});

		return _react2.default.createElement(
			'div',
			{
				className: cx('&', '&-base', {
					'&-is-expanded': isExpanded,
					'&-direction-down': isExpanded && direction === 'down',
					'&-direction-up': isExpanded && direction === 'up'
				}, className),
				style: style
			},
			_react2.default.createElement(
				_ContextMenu2.default,
				_extends({}, contextMenuProps, {
					portalId: portalId,
					isExpanded: isExpanded,
					direction: direction,
					alignment: alignment,
					onClickOut: onCollapse
				}),
				_react2.default.createElement(
					_ContextMenu2.default.Target,
					null,
					_react2.default.createElement('div', _extends({}, !isDisabled ? {
						tabIndex: 0,
						onClick: this.handleClick,
						onKeyDown: this.handleKeydown
					} : null, controlProps, {
						className: cx('&-Control', (0, _get3.default)(controlProps, 'className'))
					}))
				),
				_react2.default.createElement(
					_ContextMenu2.default.FlyOut,
					{
						className: cx('&', className),
						style: flyOutStyle
					},
					!(0, _isEmpty3.default)(headerProps) && _react2.default.createElement('div', _extends({}, headerProps, {
						className: cx('&-Header', headerProps.className),
						onKeyDown: this.handleKeydown,
						ref: function ref(header) {
							return _this2._header = header;
						}
					})),
					_react2.default.createElement(
						'div',
						{
							className: cx('&-option-container'),
							style: (0, _assign3.default)({}, flyOutStyle, optionContainerStyle)
						},
						(0, _map3.default)(nullOptions, function (optionProps) {
							return _this2.renderOption(optionProps, null);
						}).concat((0, _isEmpty3.default)(nullOptions) ? [] : [_react2.default.createElement('div', {
							key: 'OptionGroup-divider-NullOption',
							className: cx('&-OptionGroup-divider')
						})]),
						joinArray(
						// for each option group,
						(0, _map3.default)(optionGroups, function (optionGroupProps, optionGroupIndex) {
							var groupedOptions = optionGroupDataLookup[optionGroupIndex];
							if (optionGroupProps.isHidden || (0, _every3.default)(groupedOptions, { optionProps: { isHidden: true } })) {
								return null;
							}

							var labelElements = (0, _componentTypes.rejectTypes)(optionGroupProps.children, [DropMenu.Control, DropMenu.OptionGroup, DropMenu.Option, DropMenu.NullOption]);
							// render label if there is one
							return ((0, _isEmpty3.default)(labelElements) ? [] : [_react2.default.createElement(
								'div',
								_extends({}, (0, _componentTypes.omitProps)(optionGroupProps, DropMenu.OptionGroup), {
									className: cx('&-label', optionGroupProps.className)
								}),
								labelElements
							)]).concat((0, _map3.default)(optionGroupDataLookup[optionGroupIndex], function (_ref) {
								var optionProps = _ref.optionProps,
								    optionIndex = _ref.optionIndex;
								return _this2.renderOption(optionProps, optionIndex, true);
							}));
							// append all ungrouped options as another unlabeled group
						}).concat((0, _isEmpty3.default)(ungroupedOptionData) ? [] : [(0, _map3.default)(ungroupedOptionData, function (_ref2) {
							var optionProps = _ref2.optionProps,
							    optionIndex = _ref2.optionIndex;
							return _this2.renderOption(optionProps, optionIndex);
						})]), function (element, index) {
							return element && _react2.default.createElement('div', {
								key: 'OptionGroup-divider-' + index,
								className: cx('&-OptionGroup-divider')
							});
						} // separate each group with divider
						)
					)
				)
			)
		);
	}
});

exports.default = (0, _stateManagement.buildHybridComponent)(DropMenu);
exports.DropMenuDumb = DropMenu;