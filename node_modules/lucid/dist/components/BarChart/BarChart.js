'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _identity2 = require('lodash/identity');

var _identity3 = _interopRequireDefault(_identity2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _chartHelpers = require('../../util/chart-helpers');

var _d3Scale = require('d3-scale');

var d3Scale = _interopRequireWildcard(_d3Scale);

var _charts = require('../../constants/charts');

var chartConstants = _interopRequireWildcard(_charts);

var _Axis = require('../Axis/Axis');

var _Axis2 = _interopRequireDefault(_Axis);

var _AxisLabel = require('../AxisLabel/AxisLabel');

var _AxisLabel2 = _interopRequireDefault(_AxisLabel);

var _Bars = require('../Bars/Bars');

var _Bars2 = _interopRequireDefault(_Bars);

var _ContextMenu = require('../ContextMenu/ContextMenu');

var _ContextMenu2 = _interopRequireDefault(_ContextMenu);

var _Legend = require('../Legend/Legend');

var _Legend2 = _interopRequireDefault(_Legend);

var _EmptyStateWrapper = require('../EmptyStateWrapper/EmptyStateWrapper');

var _EmptyStateWrapper2 = _interopRequireDefault(_EmptyStateWrapper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-BarChart');

var arrayOf = _propTypes2.default.arrayOf,
    func = _propTypes2.default.func,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    shape = _propTypes2.default.shape,
    string = _propTypes2.default.string,
    array = _propTypes2.default.array,
    bool = _propTypes2.default.bool,
    oneOfType = _propTypes2.default.oneOfType;

/**
 * {"categories": ["visualizations", "charts"], "madeFrom": ["ContextMenu", "ToolTip"]}
 *
 * Bar charts are great for showing data that fits neatly in to "buckets". The
 * x axis data must be strings, and the y axis data must be numeric.
 */

var BarChart = (0, _componentTypes.createClass)({
	displayName: 'BarChart',

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root element.
   */
		className: string,
		/**
   * Height of the chart.
   */
		height: number,
		/**
   * Width of the chart.
   */
		width: number,
		/**
   * An object defining the margins of the chart. These margins typically
   * contain the axis and labels.
   */
		margin: shape({
			top: number,
			right: number,
			bottom: number,
			left: number
		}),
		/**
   * Data for the chart. E.g.
   *
   *     [
   *       { x: 'Monday'    , y: 1 } ,
   *       { x: 'Tuesday'   , y: 2 } ,
   *       { x: 'Wednesday' , y: 3 } ,
   *       { x: 'Thursday'  , y: 2 } ,
   *       { x: 'Friday'    , y: 5 } ,
   *     ]
   */
		data: arrayOf(object),
		/**
   * An object with human readable names for fields that will be used for
   * legends and tooltips. E.g:
   *
   *     {
   *       x: 'Date',
   *       y: 'Impressions',
   *     }
   *
   */
		legend: object,
		/**
   * Controls the visibility of the `LoadingMessage`.
   */
		isLoading: bool,
		/**
   * Show tool tips on hover.
   */
		hasToolTips: bool,
		/**
   * Show a legend at the bottom of the chart.
   */
		hasLegend: bool,
		/**
   * Takes one of the palettes exported from `lucid.chartConstants`.
   * Available palettes:
   *
   * - `PALETTE_6` (default)
   * - `PALETTE_30`
   * - `PALETTE_MONOCHROME_0_5`
   * - `PALETTE_MONOCHROME_1_5`
   * - `PALETTE_MONOCHROME_2_5`
   * - `PALETTE_MONOCHROME_3_5`
   * - `PALETTE_MONOCHROME_4_5`
   * - `PALETTE_MONOCHROME_5_5`
   *
   */
		palette: arrayOf(string),
		/**
   * You can pass in an object if you want to map x values to
   * `lucid.chartConstants` or custom colors:
   *
   *     {
   *       'imps': COLOR_0,
   *       'rev': COLOR_3,
   *       'clicks': '#abc123',
   *     }
   */
		colorMap: object,

		/**
   * The field we should look up your x data by. Your actual x data must be
   * strings.
   */
		xAxisField: string,
		/**
   * There are some cases where you need to only show a "sampling" of ticks
   * on the x axis. This number will control that.
   */
		xAxisTickCount: number,
		/**
   * An optional function used to format your x axis data. If you don't
   * provide anything, we'll use an identity function.
   */
		xAxisFormatter: func,
		/**
   * Set a title for the x axis.
   */
		xAxisTitle: string,
		/**
   * Set a color for the x axis title. Use the color constants exported off
   * `lucid.chartConstants`. E.g.:
   *
   * - `COLOR_0`
   * - `COLOR_GOOD`
   * - `'#123abc'` // custom color hex
   *
   * `number` is supported only for backwards compatability.
   */
		xAxisTitleColor: oneOfType([number, string]),

		/**
   * An array of your y axis fields. Typically this will just be a single
   * item unless you need to display grouped or stacked bars. The order of
   * the array determines the series order in the chart.
   */
		yAxisFields: array,
		/**
   * The minimum number the y axis should display. Typically this
   * should be be `0`.
   */
		yAxisMin: number,
		/**
   * The maximum number the y axis should display. This should almost always
   * be the largest number from your dataset.
   */
		yAxisMax: number,
		/**
   * An optional function used to format your y axis data. If you don't
   * provide anything, we use the default D3 number formatter.
   */
		yAxisFormatter: func,
		/**
   * Stack the y axis data instead of showing it as groups. This is only
   * useful if you have multiple `yAxisFields`. Stacking will cause the chart
   * to be aggregated by sum.
   */
		yAxisIsStacked: bool,
		/**
   * There are some cases where you need to only show a "sampling" of ticks
   * on the y axis. This number will control that.
   */
		yAxisTickCount: number,
		/**
   * Set a title for the y axis.
   */
		yAxisTitle: string,
		/**
   * Set a color for the y axis title. Use the color constants exported off
   * `lucid.chartConstants`. E.g.:
   *
   * - `COLOR_0`
   * - `COLOR_GOOD`
   * - `'#123abc'` // custom color hex
   *
   * `number` is supported only for backwards compatability.
   */
		yAxisTitleColor: oneOfType([number, string]),
		/**
   * An optional function used to format your y axis titles and data in the
   * tooltips. The first value is the name of your y field, the second value
   * is your post-formatted y value, and the third value is your non-formatted
   * y-value.
   *
   * Signature: `(yField, yValueFormatted, yValue) => {}`
   */
		yAxisTooltipFormatter: func,
		/**
   * An optional function used to format data in the tooltips.
   */
		yAxisTooltipDataFormatter: func
	},

	statics: {
		PADDING: 0.05,
		PADDING_GROUPED_OR_STACKED: 0.3,
		MARGIN: {
			top: 10,
			right: 20,
			bottom: 50,
			left: 80
		}
	},

	getDefaultProps: function getDefaultProps() {
		return {
			height: 400,
			width: 1000,
			// duplicated because `statics` aren't available during getDefaultProps
			margin: {
				top: 10,
				right: 20,
				bottom: 50,
				left: 80
			},
			palette: chartConstants.PALETTE_6,
			hasToolTips: true,
			hasLegend: false,

			xAxisField: 'x',
			xAxisTickCount: null,
			xAxisTitle: null,
			xAxisTitleColor: '#000',
			xAxisFormatter: _identity3.default,

			yAxisFields: ['y'],
			yAxisTickCount: null,
			yAxisIsStacked: false,
			yAxisMin: 0,
			yAxisTitle: null,
			yAxisTitleColor: '#000',
			yAxisTooltipFormatter: function yAxisTooltipFormatter(yField, yValueFormatted) {
				return yField + ': ' + yValueFormatted;
			}
		};
	},


	components: {
		/**
   * Renders wrapper when the data table has no data.
   */
		EmptyStateWrapper: _EmptyStateWrapper2.default
	},

	render: function render() {
		var _props = this.props,
		    className = _props.className,
		    height = _props.height,
		    width = _props.width,
		    marginOriginal = _props.margin,
		    data = _props.data,
		    legend = _props.legend,
		    isLoading = _props.isLoading,
		    hasToolTips = _props.hasToolTips,
		    hasLegend = _props.hasLegend,
		    palette = _props.palette,
		    colorMap = _props.colorMap,
		    xAxisField = _props.xAxisField,
		    xAxisFormatter = _props.xAxisFormatter,
		    xAxisTitle = _props.xAxisTitle,
		    xAxisTitleColor = _props.xAxisTitleColor,
		    xAxisTickCount = _props.xAxisTickCount,
		    yAxisFields = _props.yAxisFields,
		    yAxisFormatter = _props.yAxisFormatter,
		    yAxisTitle = _props.yAxisTitle,
		    yAxisTitleColor = _props.yAxisTitleColor,
		    yAxisIsStacked = _props.yAxisIsStacked,
		    yAxisTickCount = _props.yAxisTickCount,
		    yAxisMin = _props.yAxisMin,
		    yAxisTooltipFormatter = _props.yAxisTooltipFormatter,
		    yAxisTooltipDataFormatter = _props.yAxisTooltipDataFormatter,
		    _props$yAxisMax = _props.yAxisMax,
		    yAxisMax = _props$yAxisMax === undefined ? yAxisIsStacked ? (0, _chartHelpers.maxByFieldsStacked)(data, yAxisFields) : (0, _chartHelpers.maxByFields)(data, yAxisFields) : _props$yAxisMax,
		    passThroughs = _objectWithoutProperties(_props, ['className', 'height', 'width', 'margin', 'data', 'legend', 'isLoading', 'hasToolTips', 'hasLegend', 'palette', 'colorMap', 'xAxisField', 'xAxisFormatter', 'xAxisTitle', 'xAxisTitleColor', 'xAxisTickCount', 'yAxisFields', 'yAxisFormatter', 'yAxisTitle', 'yAxisTitleColor', 'yAxisIsStacked', 'yAxisTickCount', 'yAxisMin', 'yAxisTooltipFormatter', 'yAxisTooltipDataFormatter', 'yAxisMax']);

		var margin = _extends({}, BarChart.MARGIN, marginOriginal);

		var svgClasses = cx(className, '&');

		var innerWidth = width - margin.left - margin.right;
		var innerHeight = height - margin.top - margin.bottom;

		// `paddingInner` determines the space between the bars or groups of bars
		var paddingInner = yAxisFields.length > 1 ? BarChart.PADDING_GROUPED_OR_STACKED : BarChart.PADDING;

		var xScale = d3Scale.scaleBand().domain((0, _map3.default)(data, xAxisField)).range([0, innerWidth]).paddingInner(paddingInner).paddingOuter(0.5);

		var yScale = d3Scale.scaleLinear().domain([yAxisMin, yAxisMax]).range([innerHeight, 0]);

		var yAxisFinalFormatter = yAxisFormatter || yScale.tickFormat();

		var yFinalFormatter = yAxisTooltipDataFormatter ? yAxisTooltipDataFormatter : yAxisFinalFormatter;

		if ((0, _isEmpty3.default)(data) || width < 1 || height < 1 || isLoading) {
			var emptyStateWrapper = (0, _componentTypes.getFirst)(this.props, BarChart.EmptyStateWrapper, _react2.default.createElement(BarChart.EmptyStateWrapper, { Title: 'You have no data.' }));

			return _react2.default.createElement(
				_EmptyStateWrapper2.default,
				_extends({}, emptyStateWrapper.props, {
					isEmpty: (0, _isEmpty3.default)(data),
					isLoading: isLoading
				}),
				emptyStateWrapper.props.children,
				_react2.default.createElement(
					'svg',
					_extends({}, (0, _componentTypes.omitProps)(passThroughs, BarChart), {
						className: svgClasses,
						width: width,
						height: height
					}),
					_react2.default.createElement(
						'g',
						{
							transform: 'translate(' + margin.left + ', ' + (innerHeight + margin.top) + ')'
						},
						_react2.default.createElement(_Axis2.default, { orient: 'bottom', scale: xScale, tickCount: xAxisTickCount })
					),
					_react2.default.createElement(
						'g',
						{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
						_react2.default.createElement(_Axis2.default, {
							orient: 'left',
							scale: yScale,
							tickFormat: yFinalFormatter,
							tickCount: yAxisTickCount
						})
					)
				)
			);
		}

		return _react2.default.createElement(
			'svg',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, BarChart), {
				className: svgClasses,
				width: width,
				height: height
			}),
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + (innerHeight + margin.top) + ')' },
				_react2.default.createElement(_Axis2.default, {
					orient: 'bottom',
					scale: xScale,
					outerTickSize: 0,
					tickCount: xAxisTickCount
				}),
				hasLegend ? _react2.default.createElement(
					_ContextMenu2.default,
					{
						direction: 'down',
						alignment: 'center',
						directonOffset: (margin.bottom / 2 + _Legend2.default.HEIGHT / 2) * -1 /* should center the legend in the bottom margin */

					},
					_react2.default.createElement(
						_ContextMenu2.default.Target,
						{ elementType: 'g' },
						_react2.default.createElement('rect', {
							className: cx('&-invisible'),
							width: innerWidth,
							height: margin.bottom
						})
					),
					_react2.default.createElement(
						_ContextMenu2.default.FlyOut,
						{ className: cx('&-legend-container') },
						_react2.default.createElement(
							_Legend2.default,
							{ orient: 'horizontal' },
							(0, _map3.default)(yAxisFields, function (field, index) {
								return _react2.default.createElement(
									_Legend2.default.Item,
									{
										key: index,
										hasPoint: true,
										hasLine: false,
										color: (0, _get3.default)(colorMap, field, palette[index % palette.length]),
										pointKind: 1
									},
									(0, _get3.default)(legend, field, field)
								);
							})
						)
					)
				) : null
			),
			xAxisTitle ? _react2.default.createElement(
				'g',
				{
					transform: 'translate(' + margin.left + ', ' + (margin.top + innerHeight) + ')'
				},
				_react2.default.createElement(_AxisLabel2.default, {
					orient: 'bottom',
					width: innerWidth,
					height: margin.bottom,
					label: xAxisTitle,
					color: (0, _isString3.default)(xAxisTitleColor) ? xAxisTitleColor : palette[xAxisTitleColor % palette.length]
				})
			) : null,
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Axis2.default, {
					orient: 'left',
					scale: yScale,
					tickFormat: yAxisFinalFormatter,
					tickCount: yAxisTickCount
				})
			),
			yAxisTitle ? _react2.default.createElement(
				'g',
				{ transform: 'translate(0, ' + margin.top + ')' },
				_react2.default.createElement(_AxisLabel2.default, {
					orient: 'left',
					width: margin.left,
					height: innerHeight,
					label: yAxisTitle,
					color: (0, _isString3.default)(yAxisTitleColor) ? yAxisTitleColor : palette[yAxisTitleColor % palette.length]
				})
			) : null,
			_react2.default.createElement(
				'g',
				{ transform: 'translate(' + margin.left + ', ' + margin.top + ')' },
				_react2.default.createElement(_Bars2.default, {
					xField: xAxisField,
					xScale: xScale,
					xFormatter: xAxisFormatter,
					yFields: yAxisFields,
					yScale: yScale,
					yFormatter: yFinalFormatter,
					yStackedMax: yAxisMax,
					data: data,
					isStacked: yAxisIsStacked,
					yTooltipFormatter: yAxisTooltipFormatter,
					hasToolTips: hasToolTips,
					legend: legend,
					palette: palette,
					colorMap: colorMap
				})
			)
		);
	}
});

exports.default = BarChart;