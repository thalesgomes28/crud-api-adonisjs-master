'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _mapValues2 = require('lodash/mapValues');

var _mapValues3 = _interopRequireDefault(_mapValues2);

var _first2 = require('lodash/first');

var _first3 = _interopRequireDefault(_first2);

var _defer2 = require('lodash/defer');

var _defer3 = _interopRequireDefault(_defer2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _noop2 = require('lodash/noop');

var _noop3 = _interopRequireDefault(_noop2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _DragCaptureZone = require('../DragCaptureZone/DragCaptureZone');

var _DragCaptureZone2 = _interopRequireDefault(_DragCaptureZone);

var _reactMotion = require('react-motion');

var _motionSpring = require('../../constants/motion-spring');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-SplitHorizontal');

var any = _propTypes2.default.any,
    bool = _propTypes2.default.bool,
    func = _propTypes2.default.func,
    node = _propTypes2.default.node,
    number = _propTypes2.default.number,
    string = _propTypes2.default.string,
    oneOfType = _propTypes2.default.oneOfType;

/**
 * {"categories": ["helpers"], "madeFrom": ["DragCaptureZone"]}
 *
 * `SplitHorizontal` renders a vertical split.
 */

var SplitHorizontal = (0, _componentTypes.createClass)({
	displayName: 'SplitHorizontal',

	_isPrivate: true,

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root
   * element. Value is run through the `classnames` library.
   */
		className: any,
		/**
   * Direct children must be types {Splitvertical.Toppane, Splitvertical.Divider, Splitvertical.BottomPane}.
   * All content is composed as children of these respective elements.
   */
		children: node,
		/**
   * Render as expanded or collapsed.
   */
		isExpanded: bool,
		/**
   * Allows animated expand and collapse behavior.
   */
		isAnimated: bool,
		/**
   * Called when the user is currently resizing the split with the Divider.
   *
   * Signature: `(height, { event, props }) => {}`
   */
		onResizing: func,
		/**
   * Called when the user resizes the split with the Divider.
   *
   * Signature: `(height, { event, props }) => {}`
   */
		onResize: func,
		/**
   * Use this prop to shift the collapsed position by a known value.
   */
		collapseShift: number
	},

	components: {
		/**
   * Top pane of the split.
   */
		TopPane: (0, _componentTypes.createClass)({
			displayName: 'SplitHorizontal.TopPane',
			propTypes: {
				/**
     * Any valid React children.
     */
				children: node,
				/**
     * Set height of this pane.
     */
				height: oneOfType([number, string]),
				/**
     * Define this pane as the primary content pane. When the split is collapsed, this pane becomes full height.
     */
				isPrimary: bool
			},
			getDefaultProps: function getDefaultProps() {
				return {
					isPrimary: false
				};
			}
		}),

		/**
   * Bottom pane of the split.
   */
		BottomPane: (0, _componentTypes.createClass)({
			displayName: 'SplitHorizontal.BottomPane',
			propTypes: {
				/**
     * Any valid React children.
     */
				children: node,
				/**
     * Set height of this pane.
     */
				height: oneOfType([number, string]),
				/**
     * Define this pane as the primary content pane. When the split is collapsed, this pane becomes full height.
     */
				isPrimary: bool
			},
			getDefaultProps: function getDefaultProps() {
				return {
					isPrimary: false
				};
			}
		}),

		/**
   * The area that separates the split panes. Can be dragged to resize them.
   */
		Divider: (0, _componentTypes.createClass)({
			displayName: 'SplitHorizontal.Divider',
			propTypes: {
				/**
     * Any valid React children.
     */
				children: node
			}
		})
	},

	getDefaultProps: function getDefaultProps() {
		return {
			isExpanded: true,
			isAnimated: false,
			collapseShift: 0,
			onResizing: _noop3.default,
			onResize: _noop3.default
		};
	},
	getInitialState: function getInitialState() {
		return {
			collapseAmount: 250
		};
	},
	getPanes: function getPanes() {
		var children = this.props.children;
		var _storedRefs = this.storedRefs,
		    topPaneRef = _storedRefs.topPane,
		    bottomPaneRef = _storedRefs.bottomPane;


		var topPaneElement = (0, _get3.default)((0, _componentTypes.filterTypes)(children, SplitHorizontal.TopPane), 0, _react2.default.createElement(SplitHorizontal.TopPane, null));
		var bottomPaneElement = (0, _get3.default)((0, _componentTypes.filterTypes)(children, SplitHorizontal.BottomPane), 0, _react2.default.createElement(SplitHorizontal.BottomPane, null));
		var primaryElement = void 0,
		    primaryRef = void 0;
		var secondaryElement = void 0,
		    secondaryRef = void 0;

		if (topPaneElement.props.isPrimary && !bottomPaneElement.props.isPrimary) {
			primaryElement = topPaneElement;
			primaryRef = topPaneRef;
			secondaryElement = bottomPaneElement;
			secondaryRef = bottomPaneRef;
		} else {
			primaryElement = bottomPaneElement;
			primaryRef = bottomPaneRef;
			secondaryElement = topPaneElement;
			secondaryRef = topPaneRef;
		}

		return {
			top: topPaneElement.props,
			bottom: bottomPaneElement.props,
			primary: primaryElement.props,
			primaryRef: primaryRef,
			secondary: secondaryElement.props,
			secondaryRef: secondaryRef
		};
	},


	// Style changes to DOM nodes are updated here to shortcut the state -> render cycle for better performance. Also the Style updates in this
	// function are entirely transient and can be flushed with a props update to `height`.
	applyDeltaToSecondaryHeight: function applyDeltaToSecondaryHeight(dY, isExpanded, secondaryStartRect, secondaryRef, secondary, bottom, innerRef, primaryRef) {
		var collapseShift = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

		if (isExpanded) {
			secondaryRef.style.flexBasis = secondaryStartRect.height + dY * (secondary === bottom ? -1 : 1) + 'px';
			return secondaryStartRect.height + dY * (secondary === bottom ? -1 : 1);
		} else {
			var overlapHeight = (secondary === bottom ? secondaryStartRect.height + dY : secondaryStartRect.height - dY) - collapseShift;

			if (overlapHeight > 0) {
				this.collapseSecondary(overlapHeight);
				return secondaryStartRect.height - overlapHeight;
			} else {
				this.expandSecondary();
				secondaryRef.style.flexBasis = (dY + collapseShift) * (secondary === bottom ? -1 : 1) + 'px';
				return (dY + collapseShift) * (secondary === bottom ? -1 : 1);
			}
		}
	},
	expandSecondary: function expandSecondary() {
		this.setState({ isExpanded: true });
	},
	collapseSecondary: function collapseSecondary(collapseAmount) {
		this.setState({ isExpanded: false, collapseAmount: collapseAmount });
	},
	disableAnimation: function disableAnimation(innerRef, secondaryRef, primaryRef) {
		innerRef.style.transition = 'all 0s';
		secondaryRef.style.transition = 'all 0s';
		primaryRef.style.transition = 'all 0s';
	},
	resetAnimation: function resetAnimation(innerRef, secondaryRef, primaryRef) {
		innerRef.style.transition = '';
		secondaryRef.style.transition = '';
		primaryRef.style.transition = '';
	},
	handleDragStart: function handleDragStart() {
		this.panes = this.getPanes();
		var _panes = this.panes,
		    secondaryRef = _panes.secondaryRef,
		    primaryRef = _panes.primaryRef;

		this.secondaryStartRect = secondaryRef.getBoundingClientRect();
		this.disableAnimation(this.storedRefs.inner, secondaryRef, primaryRef);
	},
	handleDrag: function handleDrag(_ref, _ref2) {
		var dY = _ref.dY;
		var event = _ref2.event;
		var _props = this.props,
		    isExpanded = _props.isExpanded,
		    collapseShift = _props.collapseShift,
		    onResizing = _props.onResizing;
		var _panes2 = this.panes,
		    secondaryRef = _panes2.secondaryRef,
		    secondary = _panes2.secondary,
		    bottom = _panes2.bottom,
		    primaryRef = _panes2.primaryRef;


		onResizing(this.applyDeltaToSecondaryHeight(dY, isExpanded, this.secondaryStartRect, secondaryRef, secondary, bottom, this.storedRefs.inner, primaryRef, collapseShift), { props: this.props, event: event });
	},
	handleDragEnd: function handleDragEnd(_ref3, _ref4) {
		var dY = _ref3.dY;
		var event = _ref4.event;
		var _props2 = this.props,
		    isExpanded = _props2.isExpanded,
		    collapseShift = _props2.collapseShift,
		    onResize = _props2.onResize;
		var _panes3 = this.panes,
		    secondaryRef = _panes3.secondaryRef,
		    secondary = _panes3.secondary,
		    bottom = _panes3.bottom,
		    primaryRef = _panes3.primaryRef;


		onResize(this.applyDeltaToSecondaryHeight(dY, isExpanded, this.secondaryStartRect, secondaryRef, secondary, bottom, this.storedRefs.inner, primaryRef, collapseShift), { props: this.props, event: event });

		this.resetAnimation(this.storedRefs.inner, secondaryRef, primaryRef);
	},
	componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		var isAnimated = nextProps.isAnimated,
		    isExpanded = nextProps.isExpanded,
		    collapseShift = nextProps.collapseShift;

		var _getPanes = this.getPanes(),
		    secondaryRef = _getPanes.secondaryRef;

		if (!isExpanded && ( // check if collapseShift changed or secondary pane collapsed
		this.props.isExpanded || this.props.collapseShift !== collapseShift)) {
			// collapse secondary
			var secondaryRect = secondaryRef.getBoundingClientRect();
			this.collapseSecondary(secondaryRect.height - collapseShift);
		} else if (!this.props.isExpanded && isExpanded) {
			// expand secondary
			this.expandSecondary();
		}

		if (this.state.isAnimated !== isAnimated) {
			this.setState({
				isAnimated: isAnimated
			});
		}
	},
	componentDidMount: function componentDidMount() {
		var _this = this;

		var _props3 = this.props,
		    isExpanded = _props3.isExpanded,
		    isAnimated = _props3.isAnimated,
		    collapseShift = _props3.collapseShift;

		var _getPanes2 = this.getPanes(),
		    primaryRef = _getPanes2.primaryRef,
		    secondaryRef = _getPanes2.secondaryRef;

		var inner = this.storedRefs.inner;


		(0, _defer3.default)(function () {
			_this.disableAnimation(inner, secondaryRef, primaryRef);
			inner.style.visibility = 'hidden';
			(0, _defer3.default)(function () {
				if (!isExpanded) {
					// collapse secondary
					var secondaryRect = secondaryRef.getBoundingClientRect();
					_this.collapseSecondary(secondaryRect.height - collapseShift);
				}

				(0, _defer3.default)(function () {
					if (isAnimated) {
						_this.setState({ isAnimated: isAnimated });
					}
					(0, _defer3.default)(function () {
						inner.style.visibility = '';
						_this.resetAnimation(inner, secondaryRef, primaryRef);
					});
				});
			});
		});
	},
	storeRef: function storeRef(name) {
		var _this2 = this;

		return function (ref) {
			_this2.storedRefs[name] = ref;
		};
	},
	componentWillMount: function componentWillMount() {
		var _props4 = this.props,
		    isAnimated = _props4.isAnimated,
		    isExpanded = _props4.isExpanded;

		this.storedRefs = {};

		this.setState({
			isAnimated: isAnimated,
			isExpanded: isExpanded
		});
	},
	render: function render() {
		var _this3 = this;

		var _props5 = this.props,
		    children = _props5.children,
		    className = _props5.className,
		    passThroughs = _objectWithoutProperties(_props5, ['children', 'className']);

		var _state = this.state,
		    isAnimated = _state.isAnimated,
		    isExpanded = _state.isExpanded,
		    collapseAmount = _state.collapseAmount;

		var _getPanes3 = this.getPanes(),
		    topPaneProps = _getPanes3.top,
		    bottomPaneProps = _getPanes3.bottom,
		    secondary = _getPanes3.secondary;

		var dividerProps = (0, _get3.default)((0, _first3.default)((0, _componentTypes.filterTypes)(children, SplitHorizontal.Divider)), 'props', {});

		var from = void 0,
		    to = void 0;

		if (!isExpanded) {
			from = { slideAmount: 0 };
			to = { slideAmount: collapseAmount };
		} else {
			from = { slideAmount: 0 };
			to = { slideAmount: 0 };
		}

		var isBottomSecondary = bottomPaneProps === secondary;

		return _react2.default.createElement(
			'div',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, SplitHorizontal), {
				className: cx('&', {
					'&-is-expanded': isExpanded,
					'&-is-animated': isAnimated
				}, className),
				style: _extends({
					flex: 1,
					overflow: 'hidden'
				}, passThroughs.style)
			}),
			_react2.default.createElement(
				_reactMotion.Motion,
				{
					defaultStyle: from,
					style: isAnimated ? (0, _mapValues3.default)(to, function (val) {
						return (0, _reactMotion.spring)(val, _motionSpring.QUICK_SLIDE_MOTION);
					}) : to
				},
				function (tween) {
					return _react2.default.createElement(
						'div',
						{
							className: cx('&-inner'),
							ref: _this3.storeRef('inner'),
							style: {
								height: '100%',
								display: 'flex',
								flexDirection: 'column',
								transform: 'translateY(' + (isBottomSecondary ? 1 : -1) * Math.round(tween.slideAmount) + 'px)'
							}
						},
						_react2.default.createElement(
							'div',
							_extends({}, (0, _componentTypes.omitProps)(topPaneProps, SplitHorizontal.TopPane), {
								className: cx('&-TopPane', {
									'&-is-secondary': topPaneProps === secondary
								}, topPaneProps.className),
								style: _extends({
									flexGrow: isBottomSecondary ? 1 : 0,
									flexShrink: isBottomSecondary ? 1 : 0,
									flexBasis: (0, _isNil3.default)(topPaneProps.height) ? topPaneProps === secondary ? 'calc(50% - 3px)' : '0%' : topPaneProps.height,
									marginTop: isBottomSecondary ? -Math.round(tween.slideAmount) : null,
									overflow: 'auto'
								}, topPaneProps.style),
								ref: _this3.storeRef('topPane')
							}),
							topPaneProps.children
						),
						_react2.default.createElement(
							_DragCaptureZone2.default,
							_extends({}, (0, _componentTypes.omitProps)(dividerProps, SplitHorizontal.Divider, [], false), {
								className: cx('&-Divider', dividerProps.className),
								onDragStart: _this3.handleDragStart,
								onDrag: _this3.handleDrag,
								onDragEnd: _this3.handleDragEnd,
								style: _extends({
									height: '6px',
									boxSizing: 'border-box'
								}, dividerProps.style)
							}),
							dividerProps.children || ' '
						),
						_react2.default.createElement(
							'div',
							_extends({}, (0, _componentTypes.omitProps)(bottomPaneProps, SplitHorizontal.BottomPane), {
								className: cx('&-BottomPane', {
									'&-is-secondary': bottomPaneProps === secondary
								}, bottomPaneProps.className),
								style: _extends({
									flexGrow: !isBottomSecondary ? 1 : 0,
									flexShrink: !isBottomSecondary ? 1 : 0,
									flexBasis: (0, _isNil3.default)(bottomPaneProps.height) ? bottomPaneProps === secondary ? 'calc(50% - 3px)' : '0%' : bottomPaneProps.height,
									marginBottom: isBottomSecondary ? null : -Math.round(tween.slideAmount),
									overflow: 'auto'
								}, bottomPaneProps.style),
								ref: _this3.storeRef('bottomPane')
							}),
							bottomPaneProps.children
						)
					);
				}
			)
		);
	}
});

exports.default = SplitHorizontal;