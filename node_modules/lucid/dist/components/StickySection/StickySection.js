'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _domHelpers = require('../../util/dom-helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-StickySection');
var node = _propTypes2.default.node,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    string = _propTypes2.default.string;

/**
 * {"categories": ["helpers"]}
 *
 * `StickySection` can be wrapped around any content to make it _stick_ to the
 * top edge of the screen when a user scrolls beyond its initial location.
 */

var StickySection = (0, _componentTypes.createClass)({
	displayName: 'StickySection',
	propTypes: {
		/**
   * any valid React children
   */
		children: node,
		/**
   * Appended to the component-specific class names set on the root element.
   */
		className: string,
		/**
   * Styles that are passed through to the root container.
   */
		style: object,
		/**
   * Pixel value from the top of the document. When scrolled passed, the
   * sticky header is no longer sticky, and renders normally.
   */
		lowerBound: number,
		/**
   * Width of section when it sticks to the top edge of the screen. When
   * omitted, it defaults to the last width of the section.
   */
		viewportWidth: number
	},

	getInitialState: function getInitialState() {
		return {
			isAboveFold: false,
			containerRect: {}
		};
	},
	handleScroll: function handleScroll() {
		var lowerBound = this.props.lowerBound;
		var _state = this.state,
		    isAboveFold = _state.isAboveFold,
		    containerRect = _state.containerRect;


		var nextContainerRect = this.getContainerRect();

		if (window.pageYOffset >= nextContainerRect.top) {
			if (!isAboveFold) {
				this.setState({
					isAboveFold: true
				});
			}
		} else {
			if (isAboveFold) {
				this.setState({
					isAboveFold: false
				});
			}
		}

		if ((0, _isNumber3.default)(lowerBound) && window.pageYOffset >= lowerBound) {
			this.setState({
				isAboveFold: false
			});
		}

		if (containerRect.bottom !== nextContainerRect.bottom || containerRect.height !== nextContainerRect.height || containerRect.left !== nextContainerRect.left || containerRect.right !== nextContainerRect.right || containerRect.top !== nextContainerRect.top || containerRect.width !== nextContainerRect.width || containerRect.scrollWidth !== nextContainerRect.scrollWidth || containerRect.frameLeft !== nextContainerRect.frameLeft) {
			this.setState({
				containerRect: nextContainerRect
			});
		}
	},
	getContainerRect: function getContainerRect() {
		var containerRect = (0, _domHelpers.getAbsoluteBoundingClientRect)(this.refs.scrollContainer);
		var stickyRect = this.refs.stickySection.getBoundingClientRect();
		var frameRect = this.refs.stickyFrame.getBoundingClientRect();

		return {
			bottom: containerRect.top + stickyRect.height,
			height: stickyRect.height,
			left: containerRect.left,
			right: containerRect.left + stickyRect.width,
			top: containerRect.top,
			scrollWidth: this.refs.stickySection.scrollWidth,
			width: containerRect.width,
			frameLeft: frameRect.left
		};
	},
	componentDidMount: function componentDidMount() {
		var _this = this;

		setTimeout(function () {
			_this.setState({
				containerRect: _this.getContainerRect()
			});
			_this.handleScroll();
		}, 1);
		window.addEventListener('scroll', this.handleScroll, true);
	},
	componentWillUnmount: function componentWillUnmount() {
		window.removeEventListener('scroll', this.handleScroll, true);
	},
	render: function render() {
		var _props = this.props,
		    children = _props.children,
		    className = _props.className,
		    style = _props.style,
		    viewportWidth = _props.viewportWidth,
		    passThroughs = _objectWithoutProperties(_props, ['children', 'className', 'style', 'viewportWidth']);

		var _state2 = this.state,
		    isAboveFold = _state2.isAboveFold,
		    containerRect = _state2.containerRect;


		return _react2.default.createElement(
			'div',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, StickySection), {
				className: cx('&', className),
				style: _extends({}, isAboveFold ? {
					height: containerRect.height
				} : {}, style),
				ref: 'scrollContainer'
			}),
			_react2.default.createElement(
				'div',
				{
					className: cx('&-sticky-frame'),
					ref: 'stickyFrame',
					style: _extends({}, isAboveFold ? {
						position: 'fixed',
						top: 0,
						width: (0, _isNumber3.default)(viewportWidth) ? viewportWidth : containerRect.width,
						height: containerRect.height,
						overflow: 'hidden'
					} : {}, style)
				},
				_react2.default.createElement(
					'div',
					{
						className: cx('&-sticky-section'),
						ref: 'stickySection',
						style: _extends({}, isAboveFold ? {
							position: 'absolute',
							top: 0,
							left: containerRect.left - containerRect.frameLeft || 0,
							width: containerRect.scrollWidth,
							height: containerRect.height
						} : {
							position: 'relative'
						}, style)
					},
					children
				)
			)
		);
	}
});

exports.default = StickySection;