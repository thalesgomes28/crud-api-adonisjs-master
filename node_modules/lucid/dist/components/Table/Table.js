'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _isNull2 = require('lodash/isNull');

var _isNull3 = _interopRequireDefault(_isNull2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _first2 = require('lodash/first');

var _first3 = _interopRequireDefault(_first2);

var _findIndex2 = require('lodash/findIndex');

var _findIndex3 = _interopRequireDefault(_findIndex2);

var _isNumber2 = require('lodash/isNumber');

var _isNumber3 = _interopRequireDefault(_isNumber2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _property2 = require('lodash/property');

var _property3 = _interopRequireDefault(_property2);

var _endsWith2 = require('lodash/endsWith');

var _endsWith3 = _interopRequireDefault(_endsWith2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _CaretIcon = require('../Icon/CaretIcon/CaretIcon');

var _CaretIcon2 = _interopRequireDefault(_CaretIcon);

var _DragCaptureZone = require('../DragCaptureZone/DragCaptureZone');

var _DragCaptureZone2 = _interopRequireDefault(_DragCaptureZone);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-Table');

var any = _propTypes2.default.any,
    bool = _propTypes2.default.bool,
    func = _propTypes2.default.func,
    node = _propTypes2.default.node,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    string = _propTypes2.default.string,
    oneOf = _propTypes2.default.oneOf;

/**
 * `Thead` renders <thead>.
 */

var Thead = (0, _componentTypes.createClass)({
	displayName: 'Table.Thead',

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root
   * element. Value is run through the `classnames` library.
   */
		className: any,
		/**
   * any valid React children
   */
		children: node
	},

	render: function render() {
		var _props = this.props,
		    children = _props.children,
		    className = _props.className,
		    passThroughs = _objectWithoutProperties(_props, ['children', 'className']);

		return _react2.default.createElement(
			'thead',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, Thead), {
				className: cx('&-Thead', className)
			}),
			renderRowsWithIdentifiedEdges((0, _componentTypes.filterTypes)(children, Tr), Th)
		);
	}
});

/**
 * `Tbody` renders <tbody>.
 */
var Tbody = (0, _componentTypes.createClass)({
	displayName: 'Table.Tbody',

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root
   * element. Value is run through the `classnames` library.
   */
		className: any,
		/**
   * any valid React children
   */
		children: node
	},

	render: function render() {
		var _props2 = this.props,
		    children = _props2.children,
		    className = _props2.className,
		    passThroughs = _objectWithoutProperties(_props2, ['children', 'className']);

		return _react2.default.createElement(
			'tbody',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, Tbody), {
				className: cx('&-Tbody', className)
			}),
			renderRowsWithIdentifiedEdges((0, _componentTypes.filterTypes)(children, Tr), Td)
		);
	}
});

/**
 * `Tr` renders <tr>.
 */
var Tr = (0, _componentTypes.createClass)({
	displayName: 'Table.Tr',

	propTypes: {
		/**
   * any valid React children
   */
		children: node,
		/**
   * Appended to the component-specific class names set on the root
   * element. Value is run through the `classnames` library.
   */
		className: any,
		/**
   * Applies disabled styles to the row.
   */
		isDisabled: bool,
		/**
   * Applies styles to the row for when the row is selected, usually by a checkbox.
   */
		isSelected: bool,
		/**
   * Applies active styles to the row, usually when the row has been clicked.
   */
		isActive: bool,
		/**
   * Applies styles to the row, used to show if a row is clickable / can be made active.
   */
		isActionable: bool
	},

	getDefaultProps: function getDefaultProps() {
		return {
			isDisabled: false,
			isSelected: false,
			isActive: false,
			isActionable: false
		};
	},
	render: function render() {
		var _props3 = this.props,
		    className = _props3.className,
		    children = _props3.children,
		    isDisabled = _props3.isDisabled,
		    isSelected = _props3.isSelected,
		    isActionable = _props3.isActionable,
		    isActive = _props3.isActive,
		    passThroughs = _objectWithoutProperties(_props3, ['className', 'children', 'isDisabled', 'isSelected', 'isActionable', 'isActive']);

		return _react2.default.createElement(
			'tr',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, Tr), {
				className: cx('&-Tr', {
					'&-is-disabled': isDisabled,
					'&-is-selected': isSelected,
					'&-is-actionable': isActionable,
					'&-is-active': isActive
				}, className)
			}),
			children
		);
	}
});

/**
 * `Th` renders <th>.
 */
var Th = (0, _componentTypes.createClass)({
	displayName: 'Table.Th',

	propTypes: {
		/**
   * Aligns the content of a cell. Can be `left`, `center`, or `right`.
   */
		align: string,
		/**
   * any valid React children
   */
		children: node,
		/**
   * Appended to the component-specific class names set on the root
   * element. Value is run through the `classnames` library.
   */
		className: any,
		/**
   * Should be `true` to render a right border.
   */
		hasBorderRight: bool,
		/**
   * Should be `true` to render a left border.
   */
		hasBorderLeft: bool,
		/**
   * Styles the cell to indicate it should be resizable and sets up drag-
   * related events to enable this resizing functionality.
   */
		isResizable: bool,
		/**
   * Styles the cell to allow column sorting.
   */
		isSortable: bool,
		/**
   * Renders a caret icon to show that the column is sorted.
   */
		isSorted: bool,
		/**
   * Called as the user drags the resize handle to resize the column atop
   * which this table header cell sits.
   */
		onResize: func,
		/**
   * Sets the direction of the caret icon when `isSorted` is also set.
   */
		sortDirection: string,
		/**
   * Styles that are passed through to root element.
   */
		style: object,
		/**
   * Sets the width of the cell.
   */
		width: number,
		/**
   * Define the cell as being in the first row.
   */
		isFirstRow: bool,
		/**
   * Define the cell as being in the last row.
   */
		isLastRow: bool,
		/**
   * Define the cell as being in the first column.
   */
		isFirstCol: bool,
		/**
   * Define the cell as being in the last column.
   */
		isLastCol: bool,
		/**
   * Define the cell as being the first 1-height cell in the row.
   */
		isFirstSingle: bool
	},

	getDefaultProps: function getDefaultProps() {
		return {
			align: 'left',
			isResizable: false,
			isSorted: false,
			sortDirection: 'up'
		};
	},
	getInitialState: function getInitialState() {
		var width = this.props.width;


		return {
			// Represents the actively changing width as the cell is resized.
			activeWidth: width || null,
			// Indicates if a `width` prop was explicitly provided.
			hasSetWidth: !!width,
			// Indicates whether the cell is currently being resized.
			isResizing: false,
			// Indicates a mouse drag is in progress
			isDragging: false,
			// Represents the width when the cell is not actively being resized.
			passiveWidth: width || null
		};
	},
	componentWillReceiveProps: function componentWillReceiveProps(_ref) {
		var width = _ref.width;

		if (!(0, _isNil3.default)(width) && width !== this.props.width) {
			this.setState({
				hasSetWidth: true,
				passiveWidth: width
			});
		}
	},
	render: function render() {
		var _props4 = this.props,
		    children = _props4.children,
		    className = _props4.className,
		    hasBorderRight = _props4.hasBorderRight,
		    hasBorderLeft = _props4.hasBorderLeft,
		    isFirstRow = _props4.isFirstRow,
		    isLastRow = _props4.isLastRow,
		    isFirstCol = _props4.isFirstCol,
		    isFirstSingle = _props4.isFirstSingle,
		    isLastCol = _props4.isLastCol,
		    align = _props4.align,
		    isResizable = _props4.isResizable,
		    isSortable = _props4.isSortable,
		    isSorted = _props4.isSorted,
		    sortDirection = _props4.sortDirection,
		    style = _props4.style,
		    passThroughs = _objectWithoutProperties(_props4, ['children', 'className', 'hasBorderRight', 'hasBorderLeft', 'isFirstRow', 'isLastRow', 'isFirstCol', 'isFirstSingle', 'isLastCol', 'align', 'isResizable', 'isSortable', 'isSorted', 'sortDirection', 'style']);

		var _state = this.state,
		    activeWidth = _state.activeWidth,
		    hasSetWidth = _state.hasSetWidth,
		    isResizing = _state.isResizing,
		    passiveWidth = _state.passiveWidth;


		return _react2.default.createElement(
			'th',
			_extends({}, (0, _omit3.default)(passThroughs, Th), {
				className: cx('&-Th', {
					'&-is-first-row': isFirstRow,
					'&-is-last-row': isLastRow,
					'&-is-first-col': isFirstCol,
					'&-is-first-single': isFirstSingle,
					'&-is-last-col': isLastCol,
					'&-align-left': align === 'left',
					'&-align-center': align === 'center',
					'&-align-right': align === 'right',
					'&-is-resizable': isResizable,
					'&-is-resizing': isResizing,
					'&-is-sortable': isSortable === false ? isSortable : isSorted || isSortable,
					'&-is-sorted': isSorted,
					'&-has-border-right': hasBorderRight,
					'&-has-border-left': hasBorderLeft
				}, className),
				ref: 'root',
				onClickCapture: this.handleClickCapture,
				onMouseEnter: this.handleMouseEnter,
				onMouseUp: this.handleMouseUp,
				style: hasSetWidth ? (0, _assign3.default)({}, style, {
					width: isResizing ? activeWidth : passiveWidth
				}) : style
			}),
			_react2.default.createElement(
				'div',
				{ className: cx('&-Th-inner') },
				_react2.default.createElement(
					'div',
					{ className: cx('&-Th-inner-content') },
					children
				),
				isSorted ? _react2.default.createElement(
					'div',
					{ className: cx('&-Th-inner-caret') },
					_react2.default.createElement(_CaretIcon2.default, {
						className: cx('&-sort-icon'),
						direction: sortDirection,
						size: 6
					})
				) : null,
				isResizable ? _react2.default.createElement(_DragCaptureZone2.default, {
					className: cx('&-Th-inner-resize'),
					onDrag: this.handleDragged,
					onDragEnd: this.handleDragEnded,
					onDragStart: this.handleDragStarted
				}) : null
			)
		);
	},
	getWidth: function getWidth() {
		var styleWidth = (0, _get3.default)(this.refs.root, 'style.width');
		if ((0, _endsWith3.default)(styleWidth, 'px')) {
			return parseInt(styleWidth);
		}
		return this.refs.root.getBoundingClientRect().width;
	},
	handleClickCapture: function handleClickCapture(event) {
		if (this.state.isDragging) {
			event.stopPropagation();
			this.setState({
				isDragging: false
			});
		}
	},
	handleMouseEnter: function handleMouseEnter() {
		this.setState({
			isDragging: this.state.isResizing
		});
	},
	handleMouseUp: function handleMouseUp() {
		this.setState({
			isDragging: this.state.isResizing
		});
	},
	handleDragEnded: function handleDragEnded(coordinates, _ref2) {
		var event = _ref2.event;

		this.setState({
			isResizing: false,
			passiveWidth: this.state.activeWidth
		});

		window.document.body.style.cursor = '';

		if (this.props.onResize) {
			this.props.onResize(this.state.activeWidth, {
				event: event,
				props: this.props
			});
		}
	},
	handleDragStarted: function handleDragStarted(coordinates, _ref3) {
		var event = _ref3.event;

		var startingWidth = this.getWidth();

		this.setState({
			activeWidth: startingWidth,
			hasSetWidth: true,
			isResizing: true,
			isDragging: true,
			passiveWidth: startingWidth
		});

		window.document.body.style.cursor = 'ew-resize';

		if (this.props.onResize) {
			this.props.onResize(startingWidth, {
				event: event,
				props: this.props
			});
		}
	},
	handleDragged: function handleDragged(coordinates, _ref4) {
		var event = _ref4.event;

		var activeWidth = this.state.passiveWidth + coordinates.dX;

		this.setState({ activeWidth: activeWidth });

		if (this.props.onResize) {
			this.props.onResize(activeWidth, {
				event: event,
				props: this.props
			});
		}
	}
});

/**
 * `Td` renders <td>.
 */
var Td = (0, _componentTypes.createClass)({
	displayName: 'Table.Td',

	propTypes: {
		/**
   * Aligns the content of a cell. Can be `left`, `center`, or `right`.
   */
		align: string,
		/**
   * Appended to the component-specific class names set on the root
   * element. Value is run through the `classnames` library.
   */
		className: any,
		/**
   * Should be `true` to render a right border.
   */
		hasBorderRight: bool,
		/**
   * Should be `true` to render a left border.
   */
		hasBorderLeft: bool,
		/**
   * Define the cell as being in the first row.
   */
		isFirstRow: bool,
		/**
   * Define the cell as being in the last row.
   */
		isLastRow: bool,
		/**
   * Define the cell as being in the first column.
   */
		isFirstCol: bool,
		/**
   * Define the cell as being in the last column.
   */
		isLastCol: bool,
		/**
   * Define the cell as being the first 1-height cell in the row.
   */
		isFirstSingle: bool
	},

	getDefaultProps: function getDefaultProps() {
		return {
			align: 'left',
			hasBorderRight: false,
			hasBorderLeft: false
		};
	},
	render: function render() {
		var _props5 = this.props,
		    className = _props5.className,
		    isFirstRow = _props5.isFirstRow,
		    isLastRow = _props5.isLastRow,
		    isFirstCol = _props5.isFirstCol,
		    isLastCol = _props5.isLastCol,
		    isFirstSingle = _props5.isFirstSingle,
		    align = _props5.align,
		    hasBorderRight = _props5.hasBorderRight,
		    hasBorderLeft = _props5.hasBorderLeft,
		    passThroughs = _objectWithoutProperties(_props5, ['className', 'isFirstRow', 'isLastRow', 'isFirstCol', 'isLastCol', 'isFirstSingle', 'align', 'hasBorderRight', 'hasBorderLeft']);

		return _react2.default.createElement('td', _extends({}, (0, _componentTypes.omitProps)(passThroughs, Td, ['sortDirection']), {
			className: cx('&-Td', {
				'&-is-first-row': isFirstRow,
				'&-is-last-row': isLastRow,
				'&-is-first-col': isFirstCol,
				'&-is-last-col': isLastCol,
				'&-is-first-single': isFirstSingle,
				'&-align-left': align === 'left',
				'&-align-center': align === 'center',
				'&-align-right': align === 'right',
				'&-has-border-right': hasBorderRight,
				'&-has-border-left': hasBorderLeft
			}, className)
		}));
	}
});

/**
 *
 * {"categories": ["table"], "madeFrom": ["CaretIcon", "DragCaptureZone"]}
 *
 * `Table` provides the most basic components to create a lucid table.
 * It is recommended to create a wrapper around this component rather than using it directly in an app.
 */
var Table = (0, _componentTypes.createClass)({
	displayName: 'Table',

	components: {
		Thead: Thead,
		Tbody: Tbody,
		Tr: Tr,
		Th: Th,
		Td: Td
	},

	propTypes: {
		/**
   * Styles that are passed through to the root container.
   */
		style: object,

		/**
   * Class names that are appended to the defaults.
   */
		className: string,

		/**
   * Adjusts the row density of the table to have more or less spacing.
   */
		density: oneOf(['compressed', 'extended']),

		/**
   * Allows light header.
   */
		hasLightHeader: bool,

		/**
   * Render the table with borders on the outer edge.
   */
		hasBorder: bool,

		/**
   * Enables word wrapping in tables cells.
   */
		hasWordWrap: bool
	},

	getDefaultProps: function getDefaultProps() {
		return {
			density: 'extended',
			hasBorder: false,
			hasWordWrap: true,
			hasLightHeader: false
		};
	},
	render: function render() {
		var _props6 = this.props,
		    className = _props6.className,
		    hasBorder = _props6.hasBorder,
		    density = _props6.density,
		    hasWordWrap = _props6.hasWordWrap,
		    hasLightHeader = _props6.hasLightHeader,
		    style = _props6.style,
		    passThroughs = _objectWithoutProperties(_props6, ['className', 'hasBorder', 'density', 'hasWordWrap', 'hasLightHeader', 'style']);

		return _react2.default.createElement('table', _extends({}, (0, _componentTypes.omitProps)(passThroughs, Table), {
			style: style,
			className: cx('&', {
				'&-density-extended': density === 'extended',
				'&-density-compressed': density === 'compressed',
				'&-has-border': hasBorder,
				'&-has-word-wrap': hasWordWrap,
				'&-has-light-header': hasLightHeader
			}, className)
		}));
	}
});

/**
 * mapToGrid
 *
 * Returns a 2 dimensional array of cell elements of the given component type. The map function can modify value of a cell.
 */
function mapToGrid(trList) {
	var cellType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'td';
	var mapFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _property3.default)('element');

	var cellRowList = (0, _map3.default)(trList, function (trElement) {
		return (0, _map3.default)((0, _componentTypes.filterTypes)(trElement.props.children, cellType));
	});
	var grid = [];

	if ((0, _isEmpty3.default)(cellRowList)) {
		return [];
	}

	// iterate over each row
	for (var rowIndex = 0; rowIndex < cellRowList.length; rowIndex++) {
		var cellRow = cellRowList[rowIndex];

		if ((0, _isNil3.default)(grid[rowIndex])) {
			grid[rowIndex] = [];
		}

		var canonicalRow = rowIndex;

		// build out each horizonal duplicates of each cell
		for (var cellElementIndex = 0; cellElementIndex < cellRow.length; cellElementIndex++) {
			var cellElement = cellRow[cellElementIndex];

			var colSpan = 1;
			var isCellIncluded = false;

			if ((0, _isNumber3.default)(cellElement.props.colSpan)) {
				colSpan = cellElement.props.colSpan;
			}

			var nilCellIndex = (0, _findIndex3.default)(grid[canonicalRow], _isNil3.default);
			var originCol = nilCellIndex !== -1 ? nilCellIndex : grid[canonicalRow].length;

			for (var currentColSpan = 0; currentColSpan < colSpan; currentColSpan++) {
				grid[canonicalRow][originCol + currentColSpan] = {
					element: cellElement,
					canonicalPosition: {
						row: canonicalRow,
						col: originCol
					},
					isOriginal: !isCellIncluded
				};
				isCellIncluded = true;
			}
		}

		// build out each vertial duplicates of each cell using the new row in the full grid
		for (var colIndex = 0; colIndex < grid[canonicalRow].length; colIndex++) {
			var gridCell = grid[canonicalRow][colIndex];
			if (gridCell.isOriginal) {
				var _cellElement = (0, _get3.default)(gridCell, 'element');
				var rowSpan = 1;

				if ((0, _isNumber3.default)((0, _get3.default)(_cellElement, 'props.rowSpan'))) {
					rowSpan = (0, _get3.default)(_cellElement, 'props.rowSpan');
				}

				for (var currentRowSpan = 1; currentRowSpan < rowSpan; currentRowSpan++) {
					if ((0, _isNil3.default)(grid[canonicalRow + currentRowSpan])) {
						grid[canonicalRow + currentRowSpan] = [];
					}

					grid[canonicalRow + currentRowSpan][colIndex] = (0, _assign3.default)({}, grid[canonicalRow + currentRowSpan - 1][colIndex], { isOriginal: false });
				}
			}
		}
	}

	// map new values to each cell in the final grid
	var finalGrid = [];
	for (var _rowIndex = 0; _rowIndex < grid.length; _rowIndex++) {
		finalGrid[_rowIndex] = [];
		for (var _colIndex = 0; _colIndex < grid[_rowIndex].length; _colIndex++) {
			finalGrid[_rowIndex][_colIndex] = mapFn(grid[_rowIndex][_colIndex], { row: _rowIndex, col: _colIndex }, finalGrid);
		}
	}

	return finalGrid;
}

/**
 * renderRowsWithIdentifiedEdges
 *
 * Returns an equivalent list of Tr's where each cell on the perimeter has props set for: `isFirstRow`, `isLastRow`, `isFirstCol`, `isLastCol`, and `isFirstSingle`
 */
function renderRowsWithIdentifiedEdges(trList, cellType) {
	var duplicateReferences = [];
	var fullCellGrid = mapToGrid(trList, cellType, function (_ref5, currentPos, grid) {
		var props = _ref5.element.props,
		    isOriginal = _ref5.isOriginal,
		    canonicalPosition = _ref5.canonicalPosition;

		if (!isOriginal) {
			// if cell spans multiple positions
			// store current position and return original cell props reference
			duplicateReferences.push(currentPos);
			return grid[canonicalPosition.row][canonicalPosition.col];
		}
		return (0, _assign3.default)({}, props); // return a new props object based on old cell
	});

	if ((0, _isEmpty3.default)(fullCellGrid)) {
		return [];
	}

	var firstRowIndex = 0;
	var lastRowIndex = fullCellGrid.length - 1;
	var firstColIndex = 0;
	var lastColIndex = (0, _first3.default)(fullCellGrid).length - 1;
	var firstSingleLookup = {};

	// decorate the props of each cell with props that indicate its role in the table
	(0, _forEach3.default)(fullCellGrid, function (cellList, rowIndex) {
		return (0, _forEach3.default)(cellList, function (cellProps, colIndex) {
			if (!(0, _isNull3.default)(cellProps)) {
				if (rowIndex === firstRowIndex) {
					cellProps.isFirstRow = true;
				}
				if (rowIndex === lastRowIndex) {
					cellProps.isLastRow = true;
				}
				if (colIndex === firstColIndex) {
					cellProps.isFirstCol = true;
				}
				if (colIndex === lastColIndex) {
					cellProps.isLastCol = true;
				}
			}

			if (!(0, _has3.default)(firstSingleLookup, rowIndex)) {
				(0, _set3.default)(firstSingleLookup, rowIndex, false);
			}
			if (!(0, _get3.default)(firstSingleLookup, rowIndex) && (0, _get3.default)(cellProps, 'rowSpan', 1) === 1) {
				(0, _set3.default)(firstSingleLookup, rowIndex, true);
				cellProps.isFirstSingle = true;
			}
		});
	});

	(0, _forEach3.default)(duplicateReferences, function (_ref6) {
		var row = _ref6.row,
		    col = _ref6.col;

		fullCellGrid[row][col] = null; // remove duplicate references from grid
	});

	// render the grid back to elements using the updated cell props
	return (0, _map3.default)(trList, function (trElement, rowIndex) {
		return _react2.default.createElement(
			Tr,
			_extends({}, trElement.props, { key: rowIndex }),
			(0, _reduce3.default)(fullCellGrid[rowIndex], function (rowChildren, cellProps, colIndex) {
				return rowChildren.concat(!(0, _isNull3.default)(cellProps) ? [_react2.default.createElement(cellType, (0, _assign3.default)({}, cellProps, { key: colIndex }))] : []);
			}, [])
		);
	});
}

exports.default = Table;