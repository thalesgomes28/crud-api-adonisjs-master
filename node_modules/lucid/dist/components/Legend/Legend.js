'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _partial2 = require('lodash/partial');

var _partial3 = _interopRequireDefault(_partial2);

var _some2 = require('lodash/some');

var _some3 = _interopRequireDefault(_some2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _Point = require('../Point/Point');

var _Point2 = _interopRequireDefault(_Point);

var _Line = require('../Line/Line');

var _Line2 = _interopRequireDefault(_Line);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-Legend');

var POINT_SIZE = 12;
var LINE_WIDTH = 22;

var number = _propTypes2.default.number,
    string = _propTypes2.default.string,
    oneOf = _propTypes2.default.oneOf,
    bool = _propTypes2.default.bool,
    func = _propTypes2.default.func;

/**
 * {"categories": ["visualizations", "chart primitives"]}
 *
 * Contrary to the other chart primitives, this component is not rendered in
 * svg. In order to sanely render horizontal legends, we need to know the width
 * of the text elements ahead of rendering time. Since we're using a variable
 * width font, the only way I know of to correctly get the width is with the
 * DOM function `getComputedTextLength`. Variable widths are much more easy to
 * implement outside of svg.
 */

var Legend = (0, _componentTypes.createClass)({
	displayName: 'Legend',

	statics: {
		HEIGHT: 28 },

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root element.
   */
		className: string,
		/**
   * Determine orientation of the legend.
   */
		orient: oneOf(['horizontal', 'vertical']),
		/**
   * Show the legend borders. Turn this off if you want to put the legend in
   * a `ToolTip` for example.
   */
		hasBorders: bool,
		/**
   * Reverse the order of items in the legend.
   */
		isReversed: bool
	},

	getDefaultProps: function getDefaultProps() {
		return {
			orient: 'vertical',
			hasBorders: true,
			isReversed: false
		};
	},


	components: {
		/**
   * Renders a `<li>` that describes the data series.
   */
		Item: (0, _componentTypes.createClass)({
			displayName: 'Legend.Item',
			propsName: 'Item',
			propTypes: {
				hasPoint: bool,
				hasLine: bool,
				/**
     * Strings should match an existing color class unless they start with a
     * '#' for specific colors. E.g.:
     *
     * - `COLOR_0`
     * - `COLOR_GOOD`
     * - `'#123abc'`
     */
				color: string,
				pointKind: number,
				onClick: func,
				/**
     * Class names that are appended to the defaults.
     */
				className: string
			}
		})
	},

	handleItemClick: function handleItemClick(index, props, event) {
		if (!props.onClick) {
			return null;
		}

		props.onClick(index, { props: props, event: event });
	},
	render: function render() {
		var _this = this;

		var _props = this.props,
		    orient = _props.orient,
		    className = _props.className,
		    hasBorders = _props.hasBorders,
		    isReversed = _props.isReversed,
		    passThroughs = _objectWithoutProperties(_props, ['orient', 'className', 'hasBorders', 'isReversed']);

		var isHorizontal = orient === 'horizontal';
		var isVertical = orient === 'vertical';
		var itemProps = (0, _map3.default)((0, _componentTypes.findTypes)(this.props, Legend.Item), 'props');
		var hasSomeLines = isVertical && (0, _some3.default)(itemProps, function (_ref) {
			var hasLine = _ref.hasLine;
			return hasLine;
		});

		return _react2.default.createElement(
			'ul',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, Legend), {
				className: cx(className, '&', {
					'&-is-horizontal': isHorizontal,
					'&-is-vertical': isVertical,
					'&-has-borders': hasBorders,
					'&-is-reversed': isReversed
				})
			}),
			(0, _map3.default)(itemProps, function (_ref2, index) {
				var hasLine = _ref2.hasLine,
				    hasPoint = _ref2.hasPoint,
				    _ref2$pointKind = _ref2.pointKind,
				    pointKind = _ref2$pointKind === undefined ? 1 : _ref2$pointKind,
				    color = _ref2.color,
				    onClick = _ref2.onClick,
				    children = _ref2.children,
				    itemClass = _ref2.className;
				return _react2.default.createElement(
					'li',
					{
						key: index,
						className: cx(itemClass, '&-Item'),
						onClick: (0, _partial3.default)(_this.handleItemClick, index, itemProps[index])
					},
					hasPoint || hasLine ? _react2.default.createElement(
						'svg',
						{
							className: cx('&-Item-indicator'),
							width: hasLine || hasSomeLines ? LINE_WIDTH : POINT_SIZE,
							height: POINT_SIZE
						},
						hasPoint ? _react2.default.createElement(_Point2.default, {
							x: hasLine || hasSomeLines ? LINE_WIDTH / 2 : POINT_SIZE / 2,
							y: POINT_SIZE / 2,
							color: color,
							kind: pointKind
						}) : null,
						hasLine ? _react2.default.createElement(_Line2.default, {
							d: 'M0,' + POINT_SIZE / 2 + ' L' + LINE_WIDTH + ',' + POINT_SIZE / 2,
							color: color
						}) : null
					) : null,
					children
				);
			})
		);
	}
});

exports.default = Legend;