'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _max2 = require('lodash/max');

var _max3 = _interopRequireDefault(_max2);

var _times2 = require('lodash/times');

var _times3 = _interopRequireDefault(_times2);

var _identity2 = require('lodash/identity');

var _identity3 = _interopRequireDefault(_identity2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _chartHelpers = require('../../util/chart-helpers');

var _componentTypes = require('../../util/component-types');

var _d3Scale = require('d3-scale');

var d3Scale = _interopRequireWildcard(_d3Scale);

var _charts = require('../../constants/charts');

var chartConstants = _interopRequireWildcard(_charts);

var _Bar = require('../Bar/Bar');

var _Bar2 = _interopRequireDefault(_Bar);

var _ToolTip = require('../ToolTip/ToolTip');

var _Legend = require('../Legend/Legend');

var _Legend2 = _interopRequireDefault(_Legend);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-Bars');

var arrayOf = _propTypes2.default.arrayOf,
    func = _propTypes2.default.func,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    bool = _propTypes2.default.bool,
    string = _propTypes2.default.string;

/**
 * {"categories": ["visualizations", "chart primitives"], "madeFrom": ["Bar", "ToolTip", "Legend"]}
 *
 * *For use within an `svg`*
 *
 * Bars are typically used to represent categorical data and can be stacked or
 * grouped.
 *
 */

var Bars = (0, _componentTypes.createClass)({
	displayName: 'Bars',

	propTypes: {
		/**
   * Appended to the component-specific class names set on the root element.
   */
		className: string,
		/**
   * De-normalized data
   *
   *     [
   *       { x: 'one', y0: 1, y1: 2, y2: 3, y3: 5 },
   *       { x: 'two', y0: 2, y1: 3, y2: 4, y3: 6 },
   *       { x: 'three', y0: 2, y1: 4, y2: 5, y3: 6 },
   *       { x: 'four', y0: 3, y1: 6, y2: 7, y3: 7 },
   *       { x: 'five', y0: 4, y1: 8, y2: 9, y3: 8 },
   *     ]
   *
   */
		data: arrayOf(object).isRequired,
		/**
   * An object with human readable names for fields that  will be used for
   * tooltips. E.g:
   *
   *     {
   *       rev: 'Revenue',
   *       imps: 'Impressions',
   *     }
   *
   */
		legend: object,
		/**
   * Show tool tips on hover.
   */
		hasToolTips: bool,
		/**
   * Takes one of the palettes exported from `lucid.chartConstants`.
   * Available palettes:
   *
   * - `PALETTE_6` (default)
   * - `PALETTE_30`
   * - `PALETTE_MONOCHROME_0_5`
   * - `PALETTE_MONOCHROME_1_5`
   * - `PALETTE_MONOCHROME_2_5`
   * - `PALETTE_MONOCHROME_3_5`
   * - `PALETTE_MONOCHROME_4_5`
   * - `PALETTE_MONOCHROME_5_5`
   *
   */
		palette: arrayOf(string),
		/**
   * You can pass in an object if you want to map fields to
   * `lucid.chartConstants` or custom colors:
   *
   *     {
   *       'imps': COLOR_0,
   *       'rev': COLOR_3,
   *       'clicks': '#abc123',
   *     }
   */
		colorMap: object,

		/**
   * The scale for the x axis. Must be a d3 band scale. Lucid exposes the
   * `lucid.d3Scale.scaleBand` library for use here.
   */
		xScale: func.isRequired,
		/**
   * The field we should look up your x data by.
   */
		xField: string,
		/**
   * Function to format the x data.
   */
		xFormatter: func,

		/**
   * The scale for the y axis. Must be a d3 scale. Lucid exposes the
   * `lucid.d3Scale` library for use here.
   */
		yScale: func.isRequired,
		/**
   * The field(s) we should look up your y data by. Each entry represents a
   * series. Your actual y data should be numeric.
   */
		yFields: arrayOf(string),
		/**
   * Function to format the y data.
   */
		yFormatter: func,
		/**
   * Typically this number can be derived from the yScale. However when we're
   * `isStacked` we need to calculate a new domain for the yScale based on
   * the sum of the data. If you need explicit control of the y max when
   * stacking, pass it in here.
   */
		yStackedMax: number,
		/**
   * An optional function used to format your y axis titles and data in the
   * tooltips. The first value is the name of your y field, the second value
   * is your post-formatted y value, and the third value is your non-formatted
   * y-value.
   *
   * Signature: `(yField, yValueFormatted, yValue) => {}`
   */
		yTooltipFormatter: func,

		/**
   * This will stack the data instead of grouping it. In order to stack the
   * data we have to calculate a new domain for the y scale that is based on
   * the `sum` of the data.
   */
		isStacked: bool,
		/**
   * Sometimes you might not want the colors to start rotating at the blue
   * color, this number will be added the bar index in determining which
   * color the bars are.
   */
		colorOffset: number
	},

	getDefaultProps: function getDefaultProps() {
		return {
			hasToolTips: true,
			xField: 'x',
			xFormatter: _identity3.default,
			yFields: ['y'],
			yFormatter: _identity3.default,
			yTooltipFormatter: function yTooltipFormatter(yField, yValueFormatted) {
				return yField + ': ' + yValueFormatted;
			},
			isStacked: false,
			colorOffset: 0,
			palette: chartConstants.PALETTE_6
		};
	},
	getInitialState: function getInitialState() {
		return {
			isHovering: false
		};
	},
	render: function render() {
		var _this = this;

		var _props = this.props,
		    className = _props.className,
		    data = _props.data,
		    legend = _props.legend,
		    hasToolTips = _props.hasToolTips,
		    palette = _props.palette,
		    colorMap = _props.colorMap,
		    colorOffset = _props.colorOffset,
		    xScale = _props.xScale,
		    xField = _props.xField,
		    xFormatter = _props.xFormatter,
		    yScaleOriginal = _props.yScale,
		    yFields = _props.yFields,
		    yFormatter = _props.yFormatter,
		    yStackedMax = _props.yStackedMax,
		    yTooltipFormatter = _props.yTooltipFormatter,
		    isStacked = _props.isStacked,
		    passThroughs = _objectWithoutProperties(_props, ['className', 'data', 'legend', 'hasToolTips', 'palette', 'colorMap', 'colorOffset', 'xScale', 'xField', 'xFormatter', 'yScale', 'yFields', 'yFormatter', 'yStackedMax', 'yTooltipFormatter', 'isStacked']);

		var _state = this.state,
		    isHovering = _state.isHovering,
		    hoveringSeriesIndex = _state.hoveringSeriesIndex;

		// This scale is used for grouped bars

		var innerXScale = d3Scale.scaleBand().domain((0, _times3.default)(yFields.length)).range([0, xScale.bandwidth()]).round(true);

		// Copy the original so we can mutate it
		var yScale = yScaleOriginal.copy();

		// If we are stacked, we need to calculate a new domain based on the sum of
		// the various series' y data. One row per series.
		var transformedData = isStacked ? (0, _chartHelpers.stackByFields)(data, yFields) : (0, _chartHelpers.extractFields)(data, yFields);

		// If we are stacked, we need to calculate a new domain based on the sum of
		// the various group's y data
		if (isStacked) {
			yScale.domain([yScale.domain()[0], yStackedMax || (0, _max3.default)((0, _map3.default)(transformedData, function (x) {
				return (0, _last3.default)((0, _last3.default)(x));
			}))]);
		}

		return _react2.default.createElement(
			'g',
			_extends({}, (0, _componentTypes.omitProps)(passThroughs, Bars), { className: cx(className, '&') }),
			(0, _map3.default)(transformedData, function (series, seriesIndex) {
				return _react2.default.createElement(
					'g',
					{ key: seriesIndex },
					(0, _map3.default)(series, function (_ref, pointsIndex) {
						var _ref2 = _slicedToArray(_ref, 2),
						    start = _ref2[0],
						    end = _ref2[1];

						return _react2.default.createElement(_Bar2.default, {
							key: pointsIndex,
							x: isStacked ? xScale(data[seriesIndex][xField]) : innerXScale(pointsIndex) + xScale(data[seriesIndex][xField]),
							y: yScale(end),
							height: yScale(start) - yScale(end),
							width: isStacked ? xScale.bandwidth() : innerXScale.bandwidth(),
							color: (0, _get3.default)(colorMap, yFields[pointsIndex], palette[(pointsIndex + colorOffset) % palette.length])
						});
					}),
					hasToolTips ? _react2.default.createElement(
						_ToolTip.ToolTipDumb,
						{
							isExpanded: isHovering && hoveringSeriesIndex === seriesIndex,
							flyOutMaxWidth: 'none'
						},
						_react2.default.createElement(
							_ToolTip.ToolTipDumb.Target,
							{ elementType: 'g' },
							_react2.default.createElement('rect', {
								className: cx('&-tooltip-hover-zone'),
								height: isStacked ? yScale.range()[0] - yScale((0, _last3.default)(series)[1]) : yScale.range()[0] - yScale((0, _max3.default)((0, _flatten3.default)(series))),
								width: xScale.bandwidth(),
								x: xScale(data[seriesIndex][xField]),
								y: yScale((0, _max3.default)((0, _flatten3.default)(series))),
								onMouseOver: function onMouseOver() {
									_this.setState({
										isHovering: true,
										hoveringSeriesIndex: seriesIndex
									});
								},
								onMouseOut: function onMouseOut() {
									_this.setState({ isHovering: false });
								}
							})
						),
						_react2.default.createElement(
							_ToolTip.ToolTipDumb.Title,
							null,
							xFormatter(data[seriesIndex][xField])
						),
						_react2.default.createElement(
							_ToolTip.ToolTipDumb.Body,
							null,
							_react2.default.createElement(
								_Legend2.default,
								{ hasBorders: false, isReversed: isStacked },
								(0, _map3.default)(yFields, function (field, fieldIndex) {
									return _react2.default.createElement(
										_Legend2.default.Item,
										{
											key: fieldIndex,
											hasPoint: true,
											pointKind: 1,
											color: (0, _get3.default)(colorMap, field, palette[(fieldIndex + colorOffset) % palette.length])
										},
										yTooltipFormatter((0, _get3.default)(legend, field, field), yFormatter(data[seriesIndex][field]), data[seriesIndex][field])
									);
								})
							)
						)
					) : null
				);
			})
		);
	}
});

exports.default = Bars;