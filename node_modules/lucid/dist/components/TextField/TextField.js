'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _noop2 = require('lodash/noop');

var _noop3 = _interopRequireDefault(_noop2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _styleHelpers = require('../../util/style-helpers');

var _componentTypes = require('../../util/component-types');

var _TextField = require('./TextField.reducers');

var _TextField2 = _interopRequireDefault(_TextField);

var _keyCode = require('../../constants/key-code');

var KEYCODE = _interopRequireWildcard(_keyCode);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var cx = _styleHelpers.lucidClassNames.bind('&-TextField');

var bool = _propTypes2.default.bool,
    string = _propTypes2.default.string,
    func = _propTypes2.default.func,
    number = _propTypes2.default.number,
    object = _propTypes2.default.object,
    oneOfType = _propTypes2.default.oneOfType;

/**
 *
 * {"categories": ["controls", "text"]}
 *
 * TextField should cover all your text input needs. It is able to handle
 * single and multi line inputs.
 *
 */

var TextField = (0, _componentTypes.createClass)({
	displayName: 'TextField',

	reducers: _TextField2.default,

	propTypes: {
		/**
   * Styles that are passed through to native control.
   */
		style: object,

		/**
   * Set the TextField to multi line mode. Under the hood this will use a
   * `textarea` instead of an `input` if set to `true`.
   */
		isMultiLine: bool,

		/**
   * Disables the TextField by greying it out.
   */
		isDisabled: bool,

		/**
   * Initial number of rows a multi line TextField should have. Ignored when
   * not in multi-line mode.
   */
		rows: number,

		/**
   * Class names that are appended to the defaults.
   */
		className: string,

		/**
   * Fires an event every time the user types text into the TextField.
   *
   * Signature: `(value, { event, props }) => {}`
   */
		onChange: func,

		/**
   * Fires an on the `input`'s onBlur.
   *
   * Signature: `(currentValue, { event, props }) => {}`
   */
		onBlur: func,

		/**
   * Fires an event, debounced by `debounceLevel`, when the user types text
   * into the TextField.
   *
   * Signature: `(value, { event, props }) => {}`
   */
		onChangeDebounced: func,

		/**
   * Fires an event on every keydown
   *
   * Signature: `({ event, props }) => {}`
   */
		onKeyDown: func,

		/**
   * Fires an event when the user hits "enter" from the TextField. You
   * shouldn't use it if you're using `isMultiLine`.
   *
   * Signature: `(value, { event, props }) => {}`
   */
		onSubmit: func,

		/**
   * Set the value of the input.
   */
		value: oneOfType([number, string]),

		/**
   * Number of milliseconds to debounce the `onChangeDebounced` callback.
   * Only useful if you provide an `onChangeDebounced` handler.
   */
		debounceLevel: number,

		/**
   * Set the holding time, in milliseconds, that the component will wait if
   * the user is typing and the component gets a new `value` prop.
   *
   * Any time the user hits a key, it starts a timer that prevents state
   * changes from flowing in to the component until the timer has elapsed.
   * This was heavily inspired by the [lazy-input][li] component.
   *
   * [li]: https://www.npmjs.com/package/lazy-input
   */
		lazyLevel: number
	},

	getDefaultProps: function getDefaultProps() {
		return {
			style: null,
			isDisabled: false,
			isMultiLine: false,
			onBlur: _noop3.default,
			onChange: _noop3.default,
			onChangeDebounced: _noop3.default,
			onSubmit: _noop3.default,
			rows: 5,
			debounceLevel: 500,
			lazyLevel: 1000,
			value: ''
		};
	},
	getInitialState: function getInitialState() {
		return {
			value: this.props.value
		};
	},
	componentWillMount: function componentWillMount() {
		var _this = this;

		// Because we want the debounceLevel to be configurable, we can't put the
		// debounced handler directly on the react class, so we set it up right
		// before mount
		this._isMounted = true;
		this._handleChangeDebounced = (0, _debounce3.default)(function () {
			var _props;

			(_props = _this.props).onChangeDebounced.apply(_props, arguments);
		}, this.props.debounceLevel);

		this._releaseHold = (0, _debounce3.default)(function () {
			if (!_this._isMounted) {
				return;
			}
			_this.setState({ isHolding: false });
		}, this.props.lazyLevel);

		this._updateWhenReady = (0, _debounce3.default)(function (newValue) {
			if (!_this._isMounted) {
				return;
			}
			if (_this.state.isHolding) {
				_this._updateWhenReady(newValue);
			} else if (newValue !== _this.state.value) {
				_this.setState({ value: newValue });
			}
		}, this.props.lazyLevel);
	},
	componentWillUnmount: function componentWillUnmount() {
		this._isMounted = false;
	},
	componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		// Allow consumer to optionally control state
		if ((0, _has3.default)(nextProps, 'value')) {
			if (this.state.isHolding) {
				this._updateWhenReady(nextProps.value);
			} else {
				this.setState({ value: nextProps.value });
			}
		}
	},
	handleChange: function handleChange(event) {
		var _props2 = this.props,
		    onChange = _props2.onChange,
		    onChangeDebounced = _props2.onChangeDebounced;


		var value = (0, _get3.default)(event, 'target.value', '');

		this.setState({ value: value, isHolding: true });
		this._releaseHold();

		onChange(value, { event: event, props: this.props });

		// Also call the debounced handler in case the user wants debounced change
		// events.
		if (onChangeDebounced !== _noop3.default) {
			event.persist(); // https://facebook.github.io/react/docs/events.html#event-pooling
			this._handleChangeDebounced(value, { event: event, props: this.props });
		}
	},
	handleBlur: function handleBlur(event) {
		var onBlur = this.props.onBlur;


		var value = (0, _get3.default)(event, 'target.value', '');

		onBlur(value, { event: event, props: this.props });
	},
	handleKeyDown: function handleKeyDown(event) {
		var props = this.props,
		    _props3 = this.props,
		    onSubmit = _props3.onSubmit,
		    onKeyDown = _props3.onKeyDown;

		var value = (0, _get3.default)(event, 'target.value', '');

		// If the consumer passed an onKeyDown, we call it
		if (onKeyDown) {
			onKeyDown({ event: event, props: props });
		}

		if (event.keyCode === KEYCODE.Enter) {
			onSubmit(value, { event: event, props: this.props });
		}
	},
	focus: function focus() {
		/* istanbul ignore next */
		this.refs.nativeElement.focus();
	},
	render: function render() {
		var _this2 = this;

		var _props4 = this.props,
		    className = _props4.className,
		    isDisabled = _props4.isDisabled,
		    isMultiLine = _props4.isMultiLine,
		    rows = _props4.rows,
		    style = _props4.style,
		    passThroughs = _objectWithoutProperties(_props4, ['className', 'isDisabled', 'isMultiLine', 'rows', 'style']);

		var value = this.state.value;


		var finalProps = _extends({}, (0, _componentTypes.omitProps)(passThroughs, TextField, ['children']), {
			className: cx('&', {
				'&-is-disabled': isDisabled,
				'&-is-multi-line': isMultiLine,
				'&-is-single-line': !isMultiLine
			}, className),
			disabled: isDisabled,
			onChange: this.handleChange,
			onBlur: this.handleBlur,
			onKeyDown: this.handleKeyDown,
			style: style,
			rows: rows,
			value: value,
			ref: function ref(_ref) {
				return _this2.refs = { nativeElement: _ref };
			}
		});

		return isMultiLine ? _react2.default.createElement('textarea', finalProps) : _react2.default.createElement('input', _extends({ type: 'text' }, finalProps));
	}
});

exports.default = TextField;