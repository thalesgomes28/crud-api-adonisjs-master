'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.reduceSelectors = undefined;

var _isUndefined2 = require('lodash/isUndefined');

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _some2 = require('lodash/some');

var _some3 = _interopRequireDefault(_some2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _identity2 = require('lodash/identity');

var _identity3 = _interopRequireDefault(_identity2);

var _memoize2 = require('lodash/memoize');

var _memoize3 = _interopRequireDefault(_memoize2);

var _mergeWith2 = require('lodash/mergeWith');

var _mergeWith3 = _interopRequireDefault(_mergeWith2);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _size2 = require('lodash/size');

var _size3 = _interopRequireDefault(_size2);

var _take2 = require('lodash/take');

var _take3 = _interopRequireDefault(_take2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _isPlainObject2 = require('lodash/isPlainObject');

var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getDeepPaths = getDeepPaths;
exports.omitFunctionPropsDeep = omitFunctionPropsDeep;
exports.bindReducerToState = bindReducerToState;
exports.bindReducersToState = bindReducersToState;
exports.getStatefulPropsContext = getStatefulPropsContext;
exports.safeMerge = safeMerge;
exports.buildHybridComponent = buildHybridComponent;
exports.buildStatefulComponent = buildStatefulComponent;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _logger = require('./logger');

var _reselect = require('reselect');

var _createReactClass = require('create-react-class');

var _createReactClass2 = _interopRequireDefault(_createReactClass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getDeepPaths(obj) {
	var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	return (0, _reduce3.default)(obj, function (terminalKeys, value, key) {
		return (0, _isPlainObject3.default)(value) ? terminalKeys.concat(getDeepPaths(value, path.concat(key))) : terminalKeys.concat([path.concat(key)]);
	}, []);
}

function omitFunctionPropsDeep(obj) {
	return (0, _reduce3.default)(obj, function (memo, value, key) {
		if ((0, _isPlainObject3.default)(value)) {
			memo[key] = omitFunctionPropsDeep(value);
		} else if (!(0, _isFunction3.default)(value)) {
			memo[key] = value;
		}
		return memo;
	}, {});
}

function bindReducerToState(reducerFunction, _ref) {
	var getState = _ref.getState,
	    setState = _ref.setState;
	var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

	var localPath = (0, _take3.default)(path, (0, _size3.default)(path) - 1);
	return (0, _assign3.default)(function () {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		if ((0, _isEmpty3.default)(localPath)) {
			setState(reducerFunction.apply(undefined, [getState()].concat(args)));
		} else {
			var localNextState = reducerFunction.apply(undefined, [(0, _get3.default)(getState(), localPath)].concat(args));
			setState((0, _set3.default)((0, _clone3.default)(getState()), localPath, localNextState));
		}
	}, { path: path });
}

function bindReducersToState(reducers, _ref2) {
	var getState = _ref2.getState,
	    setState = _ref2.setState;

	return (0, _reduce3.default)(getDeepPaths(reducers), function (memo, path) {
		return (0, _set3.default)(memo, path, bindReducerToState((0, _get3.default)(reducers, path), { getState: getState, setState: setState }, path));
	}, {});
}

function getStatefulPropsContext(reducers, _ref3) {
	var getState = _ref3.getState,
	    setState = _ref3.setState;

	var boundReducers = bindReducersToState(reducers, { getState: getState, setState: setState });

	var combineFunctionsCustomizer = function combineFunctionsCustomizer(objValue, srcValue) {
		if ((0, _isFunction3.default)(srcValue) && (0, _isFunction3.default)(objValue)) {
			return function () {
				objValue.apply(undefined, arguments);
				return srcValue.apply(undefined, arguments);
			};
		}

		return safeMerge(objValue, srcValue);
	};

	var bindFunctionOverwritesCustomizer = function bindFunctionOverwritesCustomizer(objValue, srcValue) {
		if ((0, _isFunction3.default)(srcValue) && (0, _isFunction3.default)(objValue)) {
			return bindReducerToState(srcValue, { getState: getState, setState: setState }, objValue.path);
		}

		return safeMerge(objValue, srcValue);
	};

	return {
		getPropReplaceReducers: function getPropReplaceReducers(props) {
			return (0, _mergeWith3.default)({}, boundReducers, getState(), props, bindFunctionOverwritesCustomizer);
		},
		getProps: function getProps(props) {
			return (0, _mergeWith3.default)({}, boundReducers, getState(), props, combineFunctionsCustomizer);
		}
	};
}

/**
 * reduceSelectors
 *
 * Generates a root selector from a tree of selectors
 * @param {Object} selectors - a tree of selectors
 * @returns {function} root selector that when called with state, calls each of
 * the selectors in the tree with the state local to that selector.
 *
 * This function is memoized because it's recursive, and we want it to reuse
 * the functions created in the recursive reduce because those functions are
 * also memoized (reselect selectors are memoized with a cache of 1) and we want
 * to maintain their caches.
 */
var reduceSelectors = exports.reduceSelectors = (0, _memoize3.default)(function (selectors) {
	if (!(0, _isPlainObject3.default)(selectors)) {
		throw new Error('Selectors must be a plain object with function or plain object values');
	}

	/**
  * For each iteration of `reduceSelectors`, we return a memoized selector so
  * that individual branches maintain reference equality if they haven't been
  * modified, even if a sibling (and therefore the parent) has been modified.
  */
	return (0, _reselect.createSelector)(_identity3.default, function (state) {
		return (0, _reduce3.default)(selectors, function (acc, selector, key) {
			return _extends({}, acc, _defineProperty({}, key, (0, _isFunction3.default)(selector) ? selector(state) : reduceSelectors(selector)(state[key])));
		}, state);
	});
});

function safeMerge(objValue, srcValue) {
	// don't merge arrays
	if ((0, _isArray3.default)(srcValue) && (0, _isArray3.default)(objValue)) {
		return srcValue;
	}

	// guards against traversing react elements which can cause cyclical recursion
	// If we don't have this clause, lodash (as of 4.7.0) will attempt to
	// deeply clone the react children, which is really freaking slow.
	if ((0, _react.isValidElement)(srcValue) || (0, _isArray3.default)(srcValue) && (0, _some3.default)(srcValue, _react.isValidElement) || (0, _isArray3.default)(srcValue) && (0, _isUndefined3.default)(objValue)) {
		return srcValue;
	}
}

function buildHybridComponent(baseComponent) {
	var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref4$replaceEvents = _ref4.replaceEvents,
	    replaceEvents = _ref4$replaceEvents === undefined ? false : _ref4$replaceEvents,
	    _ref4$reducers = _ref4.reducers,
	    reducers = _ref4$reducers === undefined ? (0, _get3.default)(baseComponent, 'definition.statics.reducers', {}) : _ref4$reducers,
	    _ref4$selectors = _ref4.selectors,
	    selectors = _ref4$selectors === undefined ? (0, _get3.default)(baseComponent, 'definition.statics.selectors', {}) : _ref4$selectors;

	var _isLucidHybridComponent = baseComponent._isLucidHybridComponent,
	    displayName = baseComponent.displayName,
	    propTypes = baseComponent.propTypes,
	    _baseComponent$defini = baseComponent.definition;
	_baseComponent$defini = _baseComponent$defini === undefined ? {} : _baseComponent$defini;
	var _baseComponent$defini2 = _baseComponent$defini.statics,
	    statics = _baseComponent$defini2 === undefined ? {} : _baseComponent$defini2;


	if (_isLucidHybridComponent) {
		_logger.logger.warnOnce(displayName, 'Lucid: you are trying to apply buildHybridComponent to ' + displayName + ', which is already a hybrid component. Lucid exports hybrid components by default. To access the dumb components, use the -Dumb suffix, e.g. "ComponentDumb"');

		return baseComponent;
	}

	var selector = reduceSelectors(selectors);

	return (0, _createReactClass2.default)({
		propTypes: propTypes,
		statics: _extends({
			_isLucidHybridComponent: true
		}, statics),
		displayName: displayName,
		getInitialState: function getInitialState() {
			var initialState = this.props.initialState; //initial state overrides

			return (0, _mergeWith3.default)({}, omitFunctionPropsDeep(baseComponent.getDefaultProps()), initialState, omitFunctionPropsDeep(this.props), safeMerge);
		},
		componentWillMount: function componentWillMount() {
			var _this = this;

			var synchronousState = this.state; //store reference to state, use in place of `this.state` in `getState`
			this.boundContext = getStatefulPropsContext(reducers, {
				getState: function getState() {
					return (0, _mergeWith3.default)({}, omitFunctionPropsDeep(synchronousState), omitFunctionPropsDeep(_this.props), safeMerge);
				},
				setState: function setState(state) {
					synchronousState = state; //synchronously update the state reference
					_this.setState(state);
				}
			});
		},
		render: function render() {
			if (replaceEvents) {
				return _react2.default.createElement(baseComponent, selector(this.boundContext.getPropReplaceReducers(this.props)), this.props.children);
			}
			return _react2.default.createElement(baseComponent, selector(this.boundContext.getProps(this.props)), this.props.children);
		}
	});
}

function buildStatefulComponent() {
	_logger.logger.warnOnce('buildHybridComponent-once', 'Lucid: buildStatefulComponent has been renamed to buildHybridComponent.');
	return buildHybridComponent.apply(undefined, arguments);
}