'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _times2 = require('lodash/times');

var _times3 = _interopRequireDefault(_times2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

exports.getAbsoluteBoundingClientRect = getAbsoluteBoundingClientRect;
exports.scrollParentTo = scrollParentTo;
exports.dispatchDOMEvent = dispatchDOMEvent;
exports.sharesAncestor = sharesAncestor;
exports.shiftChildren = shiftChildren;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getAbsoluteBoundingClientRect(domNode) {
	var elementRect = domNode.getBoundingClientRect();

	return {
		bottom: elementRect.bottom + window.pageYOffset,
		top: elementRect.top + window.pageYOffset,
		left: elementRect.left + window.pageXOffset,
		right: elementRect.right + window.pageXOffset,
		height: elementRect.height,
		width: elementRect.width
	};
}

function scrollParentTo(domNode) {
	var additionalOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	if (domNode) {
		var parentNode = domNode.parentNode;
		if (parentNode.scrollTop > domNode.offsetTop - additionalOffset) {
			// if the top of the node is above the scroll line,
			// align to top
			parentNode.scrollTop = domNode.offsetTop - additionalOffset;
		} else if (parentNode.scrollTop + parentNode.clientHeight < domNode.offsetTop + domNode.offsetHeight) {
			// else if the bottom of the node is below the fold,
			// align to bottom
			parentNode.scrollTop = domNode.offsetHeight - (parentNode.clientHeight - domNode.offsetTop);
		} // else don't need to align anything
	}
}

function dispatchDOMEvent(node, eventName, assignedEventProps) {
	var event = document.createEvent('Event');
	event.initEvent(eventName, true, true);
	node.dispatchEvent((0, _assign3.default)(event, assignedEventProps));
	return event;
}

/**
 * sharesAncestor
 *
 * Recursively looks at `node` and its parents for `nodeName` and makes
 * sure it contains `siblingNode`.
 *
 * @param {element} node - dom node to check if any of its ancestors are a `<label>`
 * @param {element} siblingNode - dom node to see if it shares an ancestor
 * @param {string} nodeName - dom node name, should be uppercased, e.g. `LABEL` or `SPAN`
 * @returns {boolean}
 */
function sharesAncestor(node, siblingNode, nodeName) {
	var currentNodeName = (0, _get3.default)(node, 'nodeName');
	var parentNode = (0, _get3.default)(node, 'parentNode');

	if (currentNodeName === nodeName) {
		return node.contains(siblingNode);
	}

	if (parentNode) {
		return sharesAncestor(parentNode, siblingNode, nodeName);
	}

	return false;
}

function shiftChildren(parent) {
	var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	if (n < 0) {
		(0, _times3.default)(Math.abs(n), function () {
			parent.appendChild(parent.children[0]);
		});
	} else if (n > 0) {
		(0, _times3.default)(n, function () {
			parent.insertBefore(parent.children[parent.children.length - 1], parent.children[0]);
		});
	}
}