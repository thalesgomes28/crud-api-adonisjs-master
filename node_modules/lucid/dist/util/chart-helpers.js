'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _times2 = require('lodash/times');

var _times3 = _interopRequireDefault(_times2);

var _isNil2 = require('lodash/isNil');

var _isNil3 = _interopRequireDefault(_isNil2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _toArray2 = require('lodash/toArray');

var _toArray3 = _interopRequireDefault(_toArray2);

var _sum2 = require('lodash/sum');

var _sum3 = _interopRequireDefault(_sum2);

var _max2 = require('lodash/max');

var _max3 = _interopRequireDefault(_max2);

var _min2 = require('lodash/min');

var _min3 = _interopRequireDefault(_min2);

var _first2 = require('lodash/first');

var _first3 = _interopRequireDefault(_first2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _castArray2 = require('lodash/castArray');

var _castArray3 = _interopRequireDefault(_castArray2);

exports.stackByFields = stackByFields;
exports.extractFields = extractFields;
exports.groupByFields = groupByFields;
exports.byFields = byFields;
exports.nearest = nearest;
exports.minByFields = minByFields;
exports.maxByFields = maxByFields;
exports.maxByFieldsStacked = maxByFieldsStacked;
exports.discreteTicks = discreteTicks;
exports.transformFromCenter = transformFromCenter;
exports.formatDate = formatDate;

var _d3TimeFormat = require('d3-time-format');

var d3TimeFormat = _interopRequireWildcard(_d3TimeFormat);

var _d3Time = require('d3-time');

var d3Time = _interopRequireWildcard(_d3Time);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * stackByFields
 *
 * D3's `stack` groups each series' data together but we sometimes we want the
 * stacked groups to remain grouped as in the original normalized data. This
 * function helps achieve that.
 *
 * @param {object[]} collection - normalized data you want to operate on
 * @param {string[]} fields - fields to pluck off for the y data
 * @return {array[]} - array of arrays, one for row in the original `collection`
 */
function stackByFields(collection, fields) {
  var fieldsArray = (0, _castArray3.default)(fields);

  return (0, _map3.default)(collection, function (d) {
    return (0, _reduce3.default)(fieldsArray, function (acc, field) {
      var dataPoint = (0, _get3.default)(d, field, 0);

      if ((0, _isEmpty3.default)(acc)) {
        return acc.concat([[0, dataPoint]]);
      }

      var last = (0, _last3.default)((0, _last3.default)(acc));

      return acc.concat([[last, last + dataPoint]]);
    }, []);
  });
}

/**
 * extractFields
 *
 * This will return the data in a similar format to stackByFields but without
 * the stacking.
 *
 * @param {object[]} collection - normalized data you want to operate on
 * @param {string[]} fields - fields to pluck off for the y data
 * @return {array[]} - array of arrays, one for each field
 */
function extractFields(collection, fields) {
  var fieldsArray = (0, _castArray3.default)(fields);

  return (0, _map3.default)(collection, function (d) {
    return (0, _map3.default)(fieldsArray, function (field) {
      return [0, (0, _get3.default)(d, field, 0)];
    });
  });
}

/**
 * groupByFields
 *
 * This will return the data in a similar format to d3Shape.stack
 * but without the stacking of the data.
 *
 * @param {object[]} collection - normalized data you want to operate on
 * @param {string[]} fields - fields to pluck off for the y data
 * @return {array[]} - array of arrays, one for each field
 */
function groupByFields(collection, fields) {
  var fieldsArray = (0, _castArray3.default)(fields);

  return (0, _map3.default)(fieldsArray, function (field) {
    return (0, _map3.default)(collection, field);
  });
}

/**
 * byFields
 *
 * Takes a collection of data and returns an array of all the fields off that
 * collection.
 *
 * @param {object[]} collection
 * @param {string[]} fields
 * @return {array}
 */
function byFields(collection, fields) {
  var fieldArray = (0, _castArray3.default)(fields);

  return (0, _reduce3.default)(fieldArray, function (acc, field) {
    return acc.concat((0, _map3.default)(collection, field));
  }, []);
}

/**
 * nearest
 *
 * Divide and conquer algorithm that helps find the nearest element to `value`
 * in `nums`
 *
 * @param {number[]} nums - sorted array of numbers to search through
 * @param {number} value - value you're trying to locate the nearest array element for
 * @return {number} - the nearest array element to the value
 */
function nearest(nums, value) {
  if (nums.length < 2) {
    return (0, _first3.default)(nums);
  }

  if (nums.length === 2) {
    return value > (nums[0] + nums[1]) / 2 ? nums[1] : nums[0];
  }

  var mid = nums.length >>> 1;

  return nums[mid] > value ? nearest(nums.slice(0, mid + 1), value) : nearest(nums.slice(mid), value);
}

/**
 * minByFields
 *
 * Returns the minimum element from a collection by a set of fields.
 *
 * @param {object[]} collection
 * @param {string[]} fields
 * @return {any}
 */
function minByFields(collection, fields) {
  return (0, _min3.default)(byFields(collection, fields));
}

/**
 * maxByFields
 *
 * Returns the maximum element from a collection by a set of fields.
 *
 * @param {object[]} collection
 * @param {string[]} fields
 * @return {any}
 */
function maxByFields(collection, fields) {
  return (0, _max3.default)(byFields(collection, fields));
}

/**
 * maxByFieldsStacked
 *
 * Returns the max sum of a set of fields from a collection
 *
 * @param {object[]} collection
 * @param {string[]} fields
 * @return {any}
 */
function maxByFieldsStacked(collection, fields) {
  var fieldArray = (0, _castArray3.default)(fields);

  var sums = (0, _reduce3.default)(collection, function (acc, item) {
    return acc.concat((0, _sum3.default)((0, _toArray3.default)((0, _pick3.default)(item, fieldArray))));
  }, []);

  return (0, _max3.default)(sums);
}

/**
 * discreteTicks
 *
 * Returns `count` evenly spaced, representative values from the `array`.
 *
 * @param {array} array
 * @param {number} size - should be greater than 1
 * @return {array}
 */
function discreteTicks(array, count) {
  if (!array || (0, _isNil3.default)(count) || array.length <= count) {
    return array;
  }

  var step = (array.length - 1) / Math.max(1, count - 1);

  return (0, _reduce3.default)((0, _times3.default)(count), function (acc, n) {
    return acc.concat(array[Math.round(n * step)]);
  }, []);
}

/**
 * transformFromCenter
 *
 * Scaling paths from their center is tricky. This function
 * helps do that be generating a translate/scale transform
 * string with the correct numbers.
 *
 * @param {number} x - the x data point where you want the path to be centered at
 * @param {number} y - the y data point where you want the path to be centered at
 * @param {number} xCenter - the x coordinate of the center of the path you're trying to transform
 * @param {number} yCenter - the x coordinate of the center of the path you're trying to transform
 * @param {number} scale - number to scale to, 2 would be 2x bigger
 * @return {string} - transform string
 */
function transformFromCenter(x, y, xCenter, yCenter, scale) {
  return 'translate(' + ((1 - scale) * xCenter + (x - xCenter)) + ', ' + ((1 - scale) * yCenter + (y - yCenter)) + ') scale(' + scale + ')';
}

var FORMAT_MILLISECOND = d3TimeFormat.timeFormat('.%L');
var FORMAT_SECOND = d3TimeFormat.timeFormat(':%S');
var FORMAT_MINUTE = d3TimeFormat.timeFormat('%I:%M');
var FORMAT_HOUR = d3TimeFormat.timeFormat('%I %p');
var FORMAT_DAY = d3TimeFormat.timeFormat('%a %d');
var FORMAT_WEEK = d3TimeFormat.timeFormat('%b %d');
var FORMAT_MONTH = d3TimeFormat.timeFormat('%b');
var FORMAT_YEAR = d3TimeFormat.timeFormat('%Y');

/**
 * formatDate
 *
 * This function was written to be used for tick formatting with d3 time
 * scales.
 *
 * @param {date} date - input date
 * @return {string} - formatted date
 */
function formatDate(date) {
  return (d3Time.timeSecond(date) < date ? FORMAT_MILLISECOND : d3Time.timeMinute(date) < date ? FORMAT_SECOND : d3Time.timeHour(date) < date ? FORMAT_MINUTE : d3Time.timeDay(date) < date ? FORMAT_HOUR : d3Time.timeMonth(date) < date ? d3Time.timeWeek(date) < date ? FORMAT_DAY : FORMAT_WEEK : d3Time.timeYear(date) < date ? FORMAT_MONTH : FORMAT_YEAR)(date);
}