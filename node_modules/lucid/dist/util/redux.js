'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _mergeWith2 = require('lodash/mergeWith');

var _mergeWith3 = _interopRequireDefault(_mergeWith2);

var _memoize2 = require('lodash/memoize');

var _memoize3 = _interopRequireDefault(_memoize2);

var _isUndefined2 = require('lodash/isUndefined');

var _isUndefined3 = _interopRequireDefault(_isUndefined2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _reduce2 = require('lodash/reduce');

var _reduce3 = _interopRequireDefault(_reduce2);

var _dropRight2 = require('lodash/dropRight');

var _dropRight3 = _interopRequireDefault(_dropRight2);

var _slice2 = require('lodash/slice');

var _slice3 = _interopRequireDefault(_slice2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _identity2 = require('lodash/identity');

var _identity3 = _interopRequireDefault(_identity2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.thunk = thunk;
exports.getReduxPrimitives = getReduxPrimitives;
exports.cleanArgs = cleanArgs;

var _reselect = require('reselect');

var _stateManagement = require('./state-management.js');

var _logger = require('./logger.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

/**
 * thunk
 *
 * Marks a function on the reducer tree as a thunk action creator so it doesn't
 * get incorporated into the redux reducer
 *
 * @return {function} with `isThunk` set to `true`
 */
function thunk(fn) {
	fn.isThunk = true;
	return fn;
}

/**
 * getReduxPrimitives
 *
 * Creates a redux reducer and connectors (inputs to redux-react's `connect`)
 *
 * @param {Object} param
 * @param {Object} param.initialState - the initial state object that the reducer will return
 * @param {Object} param.reducers - a tree of lucid reducers
 * @param {string[]} param.rootPath - array of strings representing the path to local state in global state
 * @param {function} param.rootSelector - a top-level selector which takes as input state that has run through every selector in param.selectors
 * @param {Object} param.selectors - a tree of lucid selectors
 * @return {Object} redux reducer and connectors
 */

function getReduxPrimitives(_ref) {
	var initialState = _ref.initialState,
	    reducers = _ref.reducers,
	    _ref$rootPath = _ref.rootPath,
	    rootPath = _ref$rootPath === undefined ? [] : _ref$rootPath,
	    _ref$rootSelector = _ref.rootSelector,
	    rootSelector = _ref$rootSelector === undefined ? _identity3.default : _ref$rootSelector,
	    selectors = _ref.selectors;

	/* istanbul ignore if */
	if (_logger.isDevMode && (0, _isEmpty3.default)(rootPath)) {
		_logger.logger.warn('`getReduxPrimitives` warning:\n`rootPath` is empty');
	}

	/* istanbul ignore if */
	if (_logger.isDevMode && !initialState) {
		_logger.logger.warn('`getReduxPrimitives` warning:\nMissing `initialState` for component at `rootPath` ' + ((0, _isArray3.default)(rootPath) ? rootPath.join(',') : rootPath) + '\nComponents should have an `initialState` property or a `getDefaultProps` defined.\n');
	}

	// we need this in scope so actionCreators can refer to it
	var dispatchTree = void 0;

	var reducer = createReduxReducer(reducers, initialState, rootPath);
	var selector = selectors ? (0, _stateManagement.reduceSelectors)(selectors) : _identity3.default;
	var rootPathSelector = function rootPathSelector(state) {
		return (0, _isEmpty3.default)(rootPath) ? state : (0, _get3.default)(state, rootPath);
	};
	var mapStateToProps = (0, _reselect.createSelector)([rootPathSelector], function (rootState) {
		return rootSelector(selector(rootState));
	});
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
		return getDispatchTree(reducers, rootPath, dispatch);
	};
	var devModeMapStateToProps = function devModeMapStateToProps(rootState) {
		/* istanbul ignore if */
		if (_logger.isDevMode && !(0, _has3.default)(rootState, rootPath)) {
			_logger.logger.warn('`getReduxPrimitives` warning:\n`rootPath` ' + rootPath + ' does not exist in the redux store.\nMake sure your `rootPath` is correct.\n');
		}
		return mapStateToProps(rootState);
	};

	return {
		reducer: reducer,
		connectors: [_logger.isDevMode ? devModeMapStateToProps : mapStateToProps, mapDispatchToProps, mergeProps]
	};

	/**
  * createActionCreator
  *
  * @param {function} node - a node in the the reducer tree, either a reducer or a thunk
  * @param {string[]} path - the path to the reducer in the reducer tree
  * @param {string[]} rootPath - array of strings representing the path to local state in global state
  * @return {function} action creator that returns either an action or a thunk
  */
	function createActionCreator(node, rootPath, path) {
		if (node.isThunk) {
			return function thunk() {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				return function thunkInner(dispatch, getState) {
					var pathToLocalDispatchTree = (0, _slice3.default)(path, rootPath.length, -1);
					var pathToLocalState = (0, _dropRight3.default)(path);
					var localDispatchTree = (0, _isEmpty3.default)(pathToLocalDispatchTree) ? dispatchTree : (0, _get3.default)(dispatchTree, pathToLocalDispatchTree);
					var getLocalState = (0, _isEmpty3.default)(pathToLocalState) ? getState : function () {
						return (0, _get3.default)(getState(), pathToLocalState);
					};

					for (var _len2 = arguments.length, rest = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
						rest[_key2 - 2] = arguments[_key2];
					}

					return node.apply(undefined, args).apply(undefined, [localDispatchTree, getLocalState, dispatch, getState].concat(rest));
				};
			};
		}
		return function actionCreator() {
			for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				args[_key3] = arguments[_key3];
			}

			var _ref2 = _logger.isDevMode ? cleanArgs(args) : args,
			    _ref3 = _toArray(_ref2),
			    payload = _ref3[0],
			    meta = _ref3.slice(1);

			return {
				type: path.join('.'),
				payload: payload,
				meta: meta
			};
		};
	}

	/**
  * createActionCreatorTree
  *
  * Walks the reducer tree and generates a tree of action creators that correspond to each reducer
  * @param {Object} reducers - a tree of lucid reducers
  * @param {string[]} rootPath - array of strings representing the path to local state in global state
  * @returns {Object} action creator tree
  */
	function createActionCreatorTree(reducers, rootPath) {
		var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rootPath;

		return (0, _reduce3.default)(reducers, function (memo, node, key) {
			var currentPath = path.concat(key);
			return _extends({}, memo, _defineProperty({}, key, (0, _isFunction3.default)(node) ? createActionCreator(node, rootPath, currentPath) : createActionCreatorTree(node, rootPath, currentPath)));
		}, {});
	}

	/**
  * getDispatchTree
  *
  * Walks the reducer tree and generates an action creator tree, then binds dispatch to each node
  * @param {Object} reducers - a tree of lucid reducers
  * @param {string[]} rootPath - array of strings representing the path to local state in global state
  * @param {function} dispatch - the redux store's `dispatch` function
  */
	function getDispatchTree(reducers, rootPath, dispatch) {
		var actionCreatorTree = createActionCreatorTree(reducers, rootPath);
		dispatchTree = bindActionCreatorTree(actionCreatorTree, dispatch);
		/* istanbul ignore if */
		if (_logger.isDevMode) {
			window.lucidReduxUtil = window.lucidReduxUtil || {};
			window.lucidReduxUtil[rootPath] = {
				actionCreatorTree: actionCreatorTree,
				dispatchTree: dispatchTree
			};
		}
		return dispatchTree;
	}
}

/**
 * createReduxReducerTree
 *
 * Walks the reducer tree and generates a tree of redux reducers, converting the
 * signature from `(state, payload) => state` to `(state, action) => state`
 * @param {Object} reducers - a tree of lucid reducers
 * @param {string[]} path - array of strings representing the path to the reducer
 * @return {Object} redux reducer tree
 */
function createReduxReducerTree(reducers) {
	var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	return (0, _reduce3.default)(reducers, function (memo, node, key) {
		// filter out thunks from the reducer tree
		if (node.isThunk) {
			return memo;
		}
		var currentPath = path.concat(key);
		return _extends({}, memo, _defineProperty({}, key, (0, _isFunction3.default)(node) ? function reduxReducer(state, action) {
			var type = action.type,
			    payload = action.payload,
			    _action$meta = action.meta,
			    meta = _action$meta === undefined ? [] : _action$meta;

			if ((0, _isUndefined3.default)(state) || type !== currentPath.join('.')) {
				return state;
			}
			return node.apply(undefined, [state, payload].concat(_toConsumableArray(meta)));
		} : createReduxReducerTree(node, currentPath)));
	}, {});
}

/**
 * createReducerFromReducerTree
 *
 * Returns a function that calls every reducer in the reducer tree with the reducer's local state and action
 * @param {Object} reduxReducerTree - tree of redux reducers with signature `(state, action) => state`
 * @param {Object} initialState - the initial state object that the reducer will return
 * @return {function} the redux reducer
 */
function createReducerFromReducerTree(reduxReducerTree, initialState) {
	return function reduxReducer(state, action) {
		if ((0, _isUndefined3.default)(state)) {
			return initialState;
		}
		return (0, _reduce3.default)(reduxReducerTree, function (state, node, key) {
			return _extends({}, state, (0, _isFunction3.default)(node) ? node(state, action) : _defineProperty({}, key, createReducerFromReducerTree(node)(state[key], action)));
		}, state);
	};
}

/**
 * createReduxReducer
 *
 * Generates a redux reducer from a tree of lucid reducers
 * @param {Object} reducers - a tree of lucid reducers
 * @param {Object} initialState - the initial state object that the reducer will return
 * @param {string[]} rootPath - array of strings representing the path to part of global state this reducer applies to
 * @return {function} the redux reducer
 */
function createReduxReducer(reducers, initialState, rootPath) {
	var reducerTree = createReduxReducerTree(reducers, rootPath);
	return createReducerFromReducerTree(reducerTree, initialState);
}

/**
 * bindActionCreatorTree
 *
 * Binds redux store.dispatch to actionCreators in a tree
 * @param {Object} actionCreatorTree - a tree of redux action creator functions
 * @param {function} dispatch - the redux store's `dispatch` function
 * @param {string[]} path - array of strings representing the path to the action creator
 */
function bindActionCreatorTree(actionCreatorTree, dispatch) {
	var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

	return (0, _reduce3.default)(actionCreatorTree, function (memo, node, key) {
		return _extends({}, memo, _defineProperty({}, key, (0, _isFunction3.default)(node) ? function boundActionCreator() {
			var action = actionCreatorTree[key].apply(actionCreatorTree, arguments);
			return dispatch(action);
		} : bindActionCreatorTree(node, dispatch, path.concat(key))));
	}, {});
}

/**
 * mergeProps
 *
 * Merges state, dispatchTree, and ownProps into a single props object
 * @param {Object} state
 * @param {Object} dispatchTree
 * @param {Object} ownProps
 * @return {Object}
 */
var mergeProps = (0, _memoize3.default)(function (state, dispatchTree, ownProps) {
	return (0, _mergeWith3.default)({}, state, dispatchTree, ownProps, _stateManagement.safeMerge);
});

function cleanArgs(args) {
	return (0, _has3.default)((0, _last3.default)(args), 'event') ? (0, _dropRight3.default)(args) : args;
}